<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Damas - PvP e IA</title>
<style>
 :root { --board-size: min(92vw, 520px); --cell-size: calc(var(--board-size) / 8); }
 body {
   background: #0f1724;
   color: white;
   font-family: Arial, sans-serif;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   min-height: 100vh;
   margin: 0;
 }
 #board {
   display: grid;
   grid-template-columns: repeat(8, var(--cell-size));
   grid-template-rows: repeat(8, var(--cell-size));
   width: var(--board-size);
   height: var(--board-size);
   border: 4px solid white;
   margin-bottom: 10px;
   touch-action: none;
 }
 .cell {
   width: var(--cell-size);
   height: var(--cell-size);
   display: flex;
   align-items: center;
   justify-content: center;
 }
 .cell.dark { background: #b58863; }
 .cell.light { background: #f0d9b5; }
 .cell.highlight { outline: 3px solid yellow; }
 .piece {
   width: calc(var(--cell-size) - min(20px, calc(var(--cell-size) * 0.22)));
   height: calc(var(--cell-size) - min(20px, calc(var(--cell-size) * 0.22)));
   border-radius: 50%;
   display: flex;
   align-items: center;
   justify-content: center;
   cursor: pointer;
 }
 .piece.red { background: #b22222; }
 .piece.black { background: black; }
 .piece.king { border: 3px solid gold; }
 .selected { outline: 3px solid cyan; }
 #info { margin-bottom: 10px; font-size: 1.2em; }
 #controls {
   display: flex;
   gap: 10px;
   margin-bottom: 10px;
 }
 button {
   padding: 6px 12px;
   font-size: 1em;
   cursor: pointer;
 }
 #score {
   margin-bottom: 10px;
 }
 @media (max-width: 640px) {
   :root { --board-size: clamp(240px, min(94vw, calc(100vh - 240px - env(safe-area-inset-bottom, 0px))), 480px); }
   body { min-height: auto; padding: 12px; padding-bottom: env(safe-area-inset-bottom, 0px); }
   h1 { font-size: 1.4rem; }
   #board { border-width: 3px; }
   #controls { flex-wrap: wrap; }
   button, select { font-size: 0.95em; }
 }
 @media (max-width: 400px) {
   #controls { flex-direction: column; width: 100%; }
   #controls > * { width: 100%; }
 }
 </style>
</head>
<body>

<h1>‚ôüÔ∏è Jogo de Damas</h1>
<div id="info">Turno: <span id="turn">Vermelho</span></div>
<div id="score">
  Vermelho: <span id="redScore">12</span> | Preto: <span id="blackScore">12</span>
</div>

<div id="board"></div>

<div id="controls">
  <button onclick="toggleAI()">Modo: <span id="modeLabel">PvP</span></button>
  <select id="aiLevel" aria-label="N√≠vel da IA">
    <option value="facil">F√°cil</option>
    <option value="medio" selected>M√©dio</option>
    <option value="dificil">Dif√≠cil</option>
  </select>
  <select id="aiRedName" aria-label="IA Vermelha" style="display:none"></select>
  <select id="aiBlackName" aria-label="IA Preta" style="display:none"></select>
  <button onclick="resetGame()">üîÑ Reiniciar</button>
</div>

<div id="aiScoreboard" style="margin-top:8px;"></div>

<script>
const board = document.getElementById('board');
const turnEl = document.getElementById('turn');
const redScoreEl = document.getElementById('redScore');
const blackScoreEl = document.getElementById('blackScore');
const modeLabel = document.getElementById('modeLabel');
const aiLevelSelect = document.getElementById('aiLevel');
const aiRedNameSelect = document.getElementById('aiRedName');
const aiBlackNameSelect = document.getElementById('aiBlackName');
const aiScoreboardEl = document.getElementById('aiScoreboard');
let game = [];
let selected = null;
let currentTurn = 'red';
let possibleMoves = [];
let useAI = false;
let redCount = 12, blackCount = 12;
let aiLevel = 'medio';
let aiMode = 'pvp'; // 'pvp' | 'hva' (Jogador vs IA) | 'ava' (IA vs IA)
let startingColor = 'red'; // alterna ou randomiza in√≠cio para reduzir vi√©s

// Perfis de IA (substitua pelos campe√µes reais que desejar)
const aiProfiles = {
  'Capivara (F√°cil)': { level: 'facil' },
  'Arara (M√©dio)': { level: 'medio' },
  'On√ßa (Dif√≠cil)': { level: 'dificil' }
};
// Placar persistente
let aiScores = JSON.parse(localStorage.getItem('damas_ai_scores') || '{}');
let aiRedName = Object.keys(aiProfiles)[1];   // padr√£o m√©dio
let aiBlackName = Object.keys(aiProfiles)[2]; // padr√£o dif√≠cil

function saveScores() {
  localStorage.setItem('damas_ai_scores', JSON.stringify(aiScores));
}
function renderScoreboard() {
  if (aiMode !== 'ava') {
    aiScoreboardEl.textContent = '';
    return;
  }
  const r = aiScores[aiRedName] || 0;
  const b = aiScores[aiBlackName] || 0;
  aiScoreboardEl.textContent = `Placar: ${aiRedName} ${r} √ó ${b} ${aiBlackName}`;
}

// Preenche selects de IA e listeners
function initAISelects() {
  const names = Object.keys(aiProfiles);
  aiRedNameSelect.innerHTML = '';
  aiBlackNameSelect.innerHTML = '';
  names.forEach(n => {
    const o1 = document.createElement('option'); o1.value = n; o1.textContent = n;
    const o2 = document.createElement('option'); o2.value = n; o2.textContent = n;
    aiRedNameSelect.appendChild(o1); aiBlackNameSelect.appendChild(o2);
  });
  aiRedNameSelect.value = aiRedName;
  aiBlackNameSelect.value = aiBlackName;
  aiRedNameSelect.onchange = () => { aiRedName = aiRedNameSelect.value; renderScoreboard(); };
  aiBlackNameSelect.onchange = () => { aiBlackName = aiBlackNameSelect.value; renderScoreboard(); };
}
initAISelects();
// Oculta o seletor inicialmente (modo PvP)
if (aiLevelSelect) {
  aiLevelSelect.addEventListener('change', () => { aiLevel = aiLevelSelect.value; });
  aiLevelSelect.style.display = 'none';
}

// Inicializa o tabuleiro e estado inicial
function initBoard() {
  board.innerHTML = '';
  game = [];
  for (let y = 0; y < 8; y++) {
    game[y] = [];
    for (let x = 0; x < 8; x++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.classList.add((x + y) % 2 === 0 ? 'light' : 'dark');
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.addEventListener('click', () => onCellClick(x, y));
      board.appendChild(cell);

      if ((x + y) % 2 !== 0 && y < 3) game[y][x] = { color: 'black', king: false };
      else if ((x + y) % 2 !== 0 && y > 4) game[y][x] = { color: 'red', king: false };
      else game[y][x] = null;
    }
  }
  renderBoard();
  updateTurn();
}

// Renderiza pe√ßas e destaques no grid
function renderBoard() {
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const idx = y * 8 + x;
      const cell = board.children[idx];
      if (!cell) continue;
      cell.innerHTML = '';
      cell.classList.remove('highlight');

      // Sele√ß√£o visual
      if (selected && selected.x === x && selected.y === y) {
        cell.classList.add('selected');
      } else {
        cell.classList.remove('selected');
      }

      const piece = game[y][x];
      if (piece) {
        const el = document.createElement('div');
        el.className = `piece ${piece.color}`;
        if (piece.king) el.classList.add('king');
        // Clique na pe√ßa encaminha para a c√©lula
        el.addEventListener('click', () => onCellClick(x, y));
        cell.appendChild(el);
      }
    }
  }
  // Real√ßa movimentos poss√≠veis
  highlightMoves();
}

function isAIColor(color) {
  return aiMode === 'ava' || (aiMode === 'hva' && color === 'black');
}

function onCellClick(x, y) {
  if (isAIColor(currentTurn)) return; // Desativa jogadas manuais da IA

  const piece = game[y][x];
  if (selected) {
    const move = possibleMoves.find(m => m.x === x && m.y === y);
    if (move) makeMove(selected.x, selected.y, move);
    selected = null;
    possibleMoves = [];
  } else if (piece && piece.color === currentTurn) {
    const mustCapture = hasAnyCapture(currentTurn);
    selected = { x, y };
    possibleMoves = getValidMoves(x, y);
    if (mustCapture) {
      // For√ßa apenas movimentos de captura quando houver capturas dispon√≠veis no turno
      possibleMoves = possibleMoves.filter(m => m.capture);
      // Se a pe√ßa selecionada n√£o tiver captura, cancela a sele√ß√£o
      if (possibleMoves.length === 0) {
        selected = null;
      }
    }
  }
  renderBoard();
}

function getValidMoves(x, y) {
  const piece = game[y][x];
  let moves = [];
  if (!piece) return moves;

  // Dama (king) com movimento alongado: desliza por qualquer n√∫mero de casas diagonais
  // e captura a dist√¢ncia, podendo pousar em qualquer casa vazia ap√≥s a pe√ßa capturada.
  if (piece.king) {
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for (const [dx, dy] of dirs) {
      let nx = x + dx;
      let ny = y + dy;

      // Movimentos sem captura: deslizar enquanto houver casas vazias
      while (inBounds(nx, ny) && !game[ny][nx]) {
        moves.push({ x: nx, y: ny });
        nx += dx;
        ny += dy;
      }

      // Captura a dist√¢ncia: exatamente uma pe√ßa advers√°ria seguida por casas vazias de pouso
      if (inBounds(nx, ny) && game[ny][nx] && game[ny][nx].color !== piece.color) {
        let cx = nx + dx;
        let cy = ny + dy;
        while (inBounds(cx, cy) && !game[cy][cx]) {
          moves.push({ x: cx, y: cy, capture: { x: nx, y: ny } });
          cx += dx;
          cy += dy;
        }
      }
    }
    return moves;
  }

  // Pe√ßa normal (n√£o-dama): permanece como antes (uma casa e captura de duas casas)
  const dirs = piece.color === 'red' ? [[-1, -1], [1, -1]] : [[-1, 1], [1, 1]];
  for (const [dx, dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (inBounds(nx, ny) && !game[ny][nx]) moves.push({ x: nx, y: ny });

    const cx = x + dx * 2, cy = y + dy * 2;
    if (inBounds(cx, cy) && !game[cy][cx] && game[ny][nx] && game[ny][nx].color !== piece.color) {
      moves.push({ x: cx, y: cy, capture: { x: nx, y: ny } });
    }
  }

  return moves;
}

function makeMove(x1, y1, move) {
  const piece = game[y1][x1];
  game[y1][x1] = null;
  game[move.y][move.x] = piece;
  if (move.capture) {
    game[move.capture.y][move.capture.x] = null;
    if (piece.color === 'red') blackCount--; else redCount--;
    updateScore();
  }
  if ((piece.color === 'red' && move.y === 0) || (piece.color === 'black' && move.y === 7))
    piece.king = true;

  selected = {x:move.x, y:move.y};
  const nextMoves = getValidMoves(move.x, move.y).filter(m => m.capture);
  if (move.capture && nextMoves.length > 0) {
    // IA continua capturas em cadeia
    if (isAIColor(currentTurn)) {
        const next = chooseAICapture(move.x, move.y, nextMoves);
        makeMove(move.x, move.y, next);
        return;
    } else {
        possibleMoves = nextMoves;
        renderBoard();
        return;
    }
  }

  currentTurn = currentTurn === 'red' ? 'black' : 'red';
  selected = null;
  possibleMoves = [];
  renderBoard();
  updateTurn();
  checkWin();

  // IA joga quando for o turno dela (suporta IA vs IA)
  if (isAIColor(currentTurn)) setTimeout(() => aiMove(currentTurn), 500);
}

function aiMove(color = 'black') {
  const level = aiMode === 'ava'
    ? (color === 'red' ? aiProfiles[aiRedName].level : aiProfiles[aiBlackName].level)
    : aiLevel;
  if (level === 'facil') return aiMoveEasy(color);
  if (level === 'medio') return aiMoveMedium(color);
  return aiMoveHard(color);
}

function aiMoveEasy(color = 'black') {
  let moves = [];
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      if (game[y][x] && game[y][x].color === color) {
        const m = getValidMoves(x, y);
        for (let move of m) moves.push({x,y,move});
      }
    }
  }
  if (moves.length === 0) return;
  const idx = Math.floor(Math.random() * moves.length);
  const chosen = moves[idx];
  makeMove(chosen.x, chosen.y, chosen.move);
}

function aiMoveMedium(color = 'black') {
  let moves = [];
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      if (game[y][x] && game[y][x].color === color) {
        const m = getValidMoves(x, y);
        for (let move of m) moves.push({x,y,move});
      }
    }
  }
  if (moves.length === 0) return;
  const captureMoves = moves.filter(m => m.move.capture);
  if (captureMoves.length > 0) {
    let best = captureMoves[0];
    let bestChain = 0;
    for (const mv of captureMoves) {
      const state = cloneGame(game);
      applyMoveOn(state, mv.x, mv.y, mv.move);
      const nextMoves = getValidMovesOn(state, mv.move.x, mv.move.y).filter(mm => mm.capture);
      if (nextMoves.length > bestChain) { bestChain = nextMoves.length; best = mv; }
    }
    makeMove(best.x, best.y, best.move);
    return;
  }
  moves.sort((a, b) => b.move.y - a.move.y);
  makeMove(moves[0].x, moves[0].y, moves[0].move);
}

function aiMoveHard(color = 'black') {
  const depth = computeHardDepth();
  const state = cloneGame(game);
  const result = minimax(state, depth, -Infinity, Infinity, color === 'black');
  if (!result || !result.best) return;
  makeMove(result.best.x, result.best.y, result.best.move);
}

// Profundidade adaptativa para IA dif√≠cil, conforme n√∫mero de pe√ßas
function computeHardDepth() {
  let pieces = 0;
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      if (game[y][x]) pieces++;
    }
  }
  if (pieces <= 10) return 5;
  if (pieces <= 16) return 4;
  return 3;
}

function minimax(state, depth, alpha, beta, maximizingPlayer) {
  const color = maximizingPlayer ? 'black' : 'red';
  const legalMoves = getLegalMovesFor(state, color);

  if (depth === 0 || legalMoves.length === 0) {
    if (legalMoves.length === 0) {
      // Sem movimentos: derrota do lado atual
      return { score: maximizingPlayer ? -9999 : 9999 };
    }
    return { score: evaluateBoard(state) };
  }

  let best = null;
  if (maximizingPlayer) {
    let maxEval = -Infinity;
    for (const mv of orderMoves(legalMoves)) {
      const s = cloneGame(state);
      // Aplicar o movimento e continuar capturas em cadeia do mesmo turno
      applyMoveOn(s, mv.x, mv.y, mv.move);
      if (mv.move.capture) {
        let lastX = mv.move.x, lastY = mv.move.y;
        let cont = getValidMovesOn(s, lastX, lastY).filter(m => m.capture);
        while (cont.length > 0) {
          const next = cont[0];
          applyMoveOn(s, lastX, lastY, next);
          lastX = next.x; lastY = next.y;
          cont = getValidMovesOn(s, lastX, lastY).filter(m => m.capture);
        }
      }
      const res = minimax(s, depth - 1, alpha, beta, false);
      if (res.score > maxEval) { maxEval = res.score; best = mv; }
      alpha = Math.max(alpha, maxEval);
      if (beta <= alpha) break;
    }
    return { score: maxEval, best };
  } else {
    let minEval = Infinity;
    for (const mv of orderMoves(legalMoves)) {
      const s = cloneGame(state);
      applyMoveOn(s, mv.x, mv.y, mv.move);
      if (mv.move.capture) {
        let lastX = mv.move.x, lastY = mv.move.y;
        let cont = getValidMovesOn(s, lastX, lastY).filter(m => m.capture);
        while (cont.length > 0) {
          const next = cont[0];
          applyMoveOn(s, lastX, lastY, next);
          lastX = next.x; lastY = next.y;
          cont = getValidMovesOn(s, lastX, lastY).filter(m => m.capture);
        }
      }
      const res = minimax(s, depth - 1, alpha, beta, true);
      if (res.score < minEval) { minEval = res.score; best = mv; }
      beta = Math.min(beta, minEval);
      if (beta <= alpha) break;
    }
    return { score: minEval, best };
  }
}

function orderMoves(moves) {
  // Capturas primeiro, depois demais; simples ordering ajuda na poda
  return moves.slice().sort((a, b) => (b.move.capture ? 1 : 0) - (a.move.capture ? 1 : 0));
}

function getAllMovesFor(state, color) {
  let moves = [];
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const p = state[y][x];
      if (p && p.color === color) {
        const ms = getValidMovesOn(state, x, y);
        for (const m of ms) moves.push({ x, y, move: m });
      }
    }
  }
  return moves;
}

function getLegalMovesFor(state, color) {
  const all = getAllMovesFor(state, color);
  const caps = all.filter(m => m.move.capture);
  return caps.length ? caps : all;
}

function chooseAICapture(fromX, fromY, options) {
  if (aiLevel === 'facil') {
    return options[Math.floor(Math.random() * options.length)];
  } else if (aiLevel === 'medio') {
    let best = options[0];
    let bestChain = 0;
    for (const opt of options) {
      const state = cloneGame(game);
      applyMoveOn(state, fromX, fromY, opt);
      const further = getValidMovesOn(state, opt.x, opt.y).filter(m => m.capture);
      if (further.length > bestChain) { bestChain = further.length; best = opt; }
    }
    return best;
  } else { // dificil
    let best = options[0];
    let bestScore = -Infinity;
    for (const opt of options) {
      const state = cloneGame(game);
      applyMoveOn(state, fromX, fromY, opt);
      const score = evaluateBoard(state);
      if (score > bestScore) { bestScore = score; best = opt; }
    }
    return best;
  }
}

function cloneGame(state) {
  const copy = [];
  for (let y = 0; y < 8; y++) {
    copy[y] = [];
    for (let x = 0; x < 8; x++) {
      const p = state[y][x];
      copy[y][x] = p ? { color: p.color, king: p.king } : null;
    }
  }
  return copy;
}

function applyMoveOn(state, x1, y1, move) {
  const piece = state[y1][x1];
  state[y1][x1] = null;
  state[move.y][move.x] = piece;
  if (move.capture) {
    state[move.capture.y][move.capture.x] = null;
  }
  if ((piece.color === 'red' && move.y === 0) || (piece.color === 'black' && move.y === 7)) {
    piece.king = true;
  }
}

function evaluateBoard(state) {
  let blackMen = 0, blackKings = 0, redMen = 0, redKings = 0;
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const p = state[y][x];
      if (!p) continue;
      if (p.color === 'black') { if (p.king) blackKings++; else blackMen++; }
      else { if (p.king) redKings++; else redMen++; }
    }
  }
  const mobilityBlack = countMovesFor(state, 'black');
  const mobilityRed = countMovesFor(state, 'red');
  return (blackMen + 2 * blackKings) - (redMen + 2 * redKings) + 0.1 * (mobilityBlack - mobilityRed);
}

function countMovesFor(state, color) {
  let count = 0;
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const p = state[y][x];
      if (p && p.color === color) {
        const m = getValidMovesOn(state, x, y);
        count += m.length;
      }
    }
  }
  return count;
}

function getValidMovesOn(state, x, y) {
  const piece = state[y][x];
  let moves = [];
  if (!piece) return moves;
  if (piece.king) {
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for (const [dx, dy] of dirs) {
      let nx = x + dx;
      let ny = y + dy;
      while (inBounds(nx, ny) && !state[ny][nx]) {
        moves.push({ x: nx, y: ny });
        nx += dx; ny += dy;
      }
      if (inBounds(nx, ny) && state[ny][nx] && state[ny][nx].color !== piece.color) {
        let cx = nx + dx; let cy = ny + dy;
        while (inBounds(cx, cy) && !state[cy][cx]) {
          moves.push({ x: cx, y: cy, capture: { x: nx, y: ny } });
          cx += dx; cy += dy;
        }
      }
    }
    return moves;
  }
  const dirs = piece.color === 'red' ? [[-1, -1], [1, -1]] : [[-1, 1], [1, 1]];
  for (const [dx, dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (inBounds(nx, ny) && !state[ny][nx]) moves.push({ x: nx, y: ny });
    const cx = x + dx * 2, cy = y + dy * 2;
    if (inBounds(cx, cy) && !state[cy][cx] && state[ny][nx] && state[ny][nx].color !== piece.color) {
      moves.push({ x: cx, y: cy, capture: { x: nx, y: ny } });
    }
  }
  return moves;
}

function inBounds(x, y) { return x >= 0 && x < 8 && y >= 0 && y < 8; }

// Verifica√ß√µes de disponibilidade de captura e de movimentos
function hasAnyCapture(color) {
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const piece = game[y][x];
      if (piece && piece.color === color) {
        const moves = getValidMoves(x, y);
        if (moves.some(m => m.capture)) return true;
      }
    }
  }
  return false;
}

function hasAnyMoves(color) {
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const piece = game[y][x];
      if (piece && piece.color === color) {
        const moves = getValidMoves(x, y);
        if (moves.length > 0) return true;
      }
    }
  }
  return false;
}

function highlightMoves() {
  for (const move of possibleMoves) {
    const cell = board.children[move.y * 8 + move.x];
    cell.classList.add('highlight');
  }
}

function updateTurn() {
  turnEl.textContent = currentTurn === 'red' ? 'Vermelho' : 'Preto';
}

function updateScore() {
  redScoreEl.textContent = redCount;
  blackScoreEl.textContent = blackCount;
}

function checkWin() {
  if (redCount === 0) {
    alert("üèÜ Preto venceu!");
    if (aiMode === 'ava') {
      aiScores[aiBlackName] = (aiScores[aiBlackName] || 0) + 1;
      saveScores(); renderScoreboard();
    }
    return;
  }
  if (blackCount === 0) {
    alert("üèÜ Vermelho venceu!");
    if (aiMode === 'ava') {
      aiScores[aiRedName] = (aiScores[aiRedName] || 0) + 1;
      saveScores(); renderScoreboard();
    }
    return;
  }
  // Vit√≥ria por bloqueio (sem movimentos dispon√≠veis)
  const redHasMoves = hasAnyMoves('red');
  const blackHasMoves = hasAnyMoves('black');
  if (!redHasMoves && blackHasMoves) {
    alert("üèÜ Preto venceu! (sem movimentos)");
    if (aiMode === 'ava') {
      aiScores[aiBlackName] = (aiScores[aiBlackName] || 0) + 1;
      saveScores(); renderScoreboard();
    }
    return;
  }
  if (!blackHasMoves && redHasMoves) {
    alert("üèÜ Vermelho venceu! (sem movimentos)");
    if (aiMode === 'ava') {
      aiScores[aiRedName] = (aiScores[aiRedName] || 0) + 1;
      saveScores(); renderScoreboard();
    }
    return;
  }
}

function toggleAI() {
  if (aiMode === 'pvp') {
    aiMode = 'hva';
    modeLabel.textContent = 'Jogador vs IA';
  } else if (aiMode === 'hva') {
    aiMode = 'ava';
    modeLabel.textContent = 'IA vs IA';
  } else {
    aiMode = 'pvp';
    modeLabel.textContent = 'PvP';
  }
  aiLevelSelect.style.display = aiMode === 'pvp' ? 'none' : 'inline-block';
  aiRedNameSelect.style.display = aiMode === 'ava' ? 'inline-block' : 'none';
  aiBlackNameSelect.style.display = aiMode === 'ava' ? 'inline-block' : 'none';
  renderScoreboard();
  resetGame();
}

function resetGame() {
  redCount = 12;
  blackCount = 12;
  selected = null;
  possibleMoves = [];
  // alterna in√≠cio em partidas consecutivas IA vs IA para equilibrar
  if (aiMode === 'ava') {
    startingColor = startingColor === 'red' ? 'black' : 'red';
    currentTurn = startingColor;
  } else {
    currentTurn = 'red';
  }
  initBoard();
  updateScore();

  if (isAIColor(currentTurn)) {
    setTimeout(() => aiMove(currentTurn), 500);
  }
}

initBoard();
</script>
</body>
</html>
