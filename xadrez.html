<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><title>Xadrez</title><style>
:root{--bg:#0f172a;--fg:#e5e7eb;--board-border:#e5e7eb;--sq-dark:#c19a6b;--sq-light:#f3d9b1}
*{box-sizing:border-box}
body{background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;padding:16px}
h1{text-align:center;margin:8px 0 12px;font-weight:600;font-size:clamp(20px,4.6vw,28px)}
#clocks{text-align:center;margin-bottom:10px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}
#clocks span{background:rgba(255,255,255,.08);border:1px solid rgba(229,231,235,.3);padding:4px 8px;border-radius:10px;font-variant-numeric:tabular-nums}
#board{width:min(92vw,520px);aspect-ratio:1/1;margin:0 auto;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border:2px solid var(--board-border);background:#ddd;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
.sq{display:flex;align-items:center;justify-content:center;font-size:clamp(22px,9vw,38px);cursor:pointer;user-select:none}
.d{background:var(--sq-dark)}.l{background:var(--sq-light)}
.sel{outline:3px solid #38bdf8}.opt{outline:3px solid #f59e0b}
.turn{margin:6px 0;text-align:center;font-size:clamp(14px,3.8vw,16px)}
#status{text-align:center;margin-bottom:6px;font-size:clamp(14px,3.8vw,16px)}
#ui{display:flex;gap:8px;justify-content:center;align-items:center;margin:12px auto;flex-wrap:wrap;max-width:min(92vw,520px)}
#ui label{display:flex;align-items:center;gap:6px;font-size:clamp(14px,3.8vw,15px)}
#ui select,#ui input[type=checkbox],#ui input[type=range]{font-size:14px;padding:6px;border-radius:8px;border:1px solid rgba(229,231,235,.25);background:rgba(255,255,255,.06);color:var(--fg)}
#ui button{padding:8px 12px;border-radius:10px;border:1px solid rgba(229,231,235,.25);background:#1f2937;color:var(--fg);box-shadow:0 2px 8px rgba(0,0,0,.38)}
#ui button:hover{filter:brightness(1.08)}
#ui button:active{transform:translateY(1px)}
@media(max-width:600px){body{padding:12px}#ui{gap:10px}}
</style><link rel="icon" href="favicon.svg" type="image/svg+xml"></head><body><h1>Jogo de Xadrez</h1><div class="turn" id="turn"></div><div id="status" style="text-align:center;margin-bottom:6px"></div><div id="clocks" style="text-align:center;margin-bottom:6px">Brancas: <span id="clockW">--:--</span> ‚Ä¢ Pretas: <span id="clockB">--:--</span></div><div id="board"></div><div id="ui"><label>Modo:<select id="mode"><option value="pvp">Jogador vs Jogador</option><option value="ai">Jogador vs IA</option><option value="ava">IA vs IA</option></select></label><label>N√≠vel:<select id="level"><option value="facil">F√°cil</option><option value="medio">M√©dio</option><option value="dificil">Dif√≠cil</option><option value="tal">Muito Dif√≠cil (Tal)</option></select></label><label>Motor:<select id="engine"><option value="tal">Tal</option><option value="stockfish" selected>Stockfish</option></select></label><label id="aiWhiteLabel" style="display:none">IA Brancas:<select id="aiWhiteName" style="display:none"></select></label><label id="aiBlackLabel" style="display:none">IA Pretas:<select id="aiBlackName" style="display:none"></select></label><label>Tempo:<select id="time"><option value="classica">Cl√°ssica (60:00)</option><option value="rapida">R√°pida (15:00)</option><option value="blitz" selected>Blitz (5:00)</option><option value="bullet">Bullet (1:00)</option></select></label><label>Som:<input id="snd" type="checkbox" checked></label><label>Volume:<input id="vol" type="range" min="0" max="100" value="100"></label><button id="reset">Reiniciar</button><button id="draw">Empatar</button><button id="resign">Desistir</button><button id="startAva" style="display:none">Iniciar</button></div><div id="aiScore" style="text-align:center;margin-top:8px"></div><script>const U={white:{K:"\u2654",Q:"\u2655",R:"\u2656",B:"\u2657",N:"\u2658",P:"\u2659"},black:{K:"\u265A",Q:"\u265B",R:"\u265C",B:"\u265D",N:"\u265E",P:"\u265F"}};let g,turn,sel=null,opts=[],mode='ai',level='medio';const bd=document.getElementById('board');
// Barra de avalia√ß√£o
const evalStyles = document.createElement('style');
evalStyles.textContent = `#evalbar{max-width:min(92vw,520px);margin:6px auto 8px;height:16px;border-radius:10px;overflow:hidden;background:linear-gradient(90deg,#f1f5f9,#334155)}#evalfill{height:100%;background:#e5e7eb;transition:width .25s ease}#evallabel{text-align:center;font-size:13px;color:#94a3b8;margin-top:4px}`;
document.head.appendChild(evalStyles);
const evalWrap = document.createElement('div'); evalWrap.id='evalwrap'; evalWrap.innerHTML = '<div id="evalbar"><div id="evalfill" style="width:50%"></div></div><div id="evallabel">Avalia√ß√£o: 0.00</div>';
document.body.insertBefore(evalWrap, document.getElementById('board'));
window.evalLatest = null;
function renderEvalBar(){
  try{
    const fill=document.getElementById('evalfill'); const lab=document.getElementById('evallabel');
    if(!fill||!lab) return;
    let text='Avalia√ß√£o: 0.00'; let pct=50;
    if(window.evalLatest && typeof window.evalLatest==='object'){
      const e=window.evalLatest;
      if(e.type==='cp' && typeof e.whiteCp==='number'){
        const cp = e.whiteCp; const capped = Math.max(-1000, Math.min(1000, cp));
        pct = Math.max(0, Math.min(100, 50 + capped/20));
        const pawns = (cp/100).toFixed(2);
        text = `Avalia√ß√£o (SF): ${cp>=0?'+':''}${pawns}`;
      } else if(e.type==='mate' && typeof e.whiteMate==='number'){
        const m = e.whiteMate; pct = m>0 ? 100 : 0; text = `Avalia√ß√£o (SF): M${Math.abs(m)}`;
      }
    } else {
      // Fallback heur√≠stico r√°pido
      const s=clone(g); const sc = evalAgg ? evalAgg(s) : 0; const capped = Math.max(-1000, Math.min(1000, sc));
      pct = Math.max(0, Math.min(100, 50 + capped/20)); const pawns=(sc/100).toFixed(2);
      text = `Avalia√ß√£o: ${sc>=0?'+':''}${pawns}`;
    }
    fill.style.width = pct + '%'; lab.textContent = text;
    // Cor din√¢mica: claro para vantagem das Brancas (>=50%), escuro para Pretas (<50%)
    fill.style.background = (pct >= 50) ? '#f1f5f9' : '#334155';
  }catch(_){ /* silencioso */ }
}
let aiWorker=null;
// Cache dedicado por motor
let talWorker=null, sfWorker=null;
// Flag para evitar reentr√¢ncia na IA
let aiThinking = false;
// Tempo de c√°lculo por lado para Stockfish
window.sfTimeMsWhite = window.sfTimeMsWhite || 15000;
window.sfTimeMsBlack = window.sfTimeMsBlack || 15000;
// Valores de pe√ßas (material) usados nas avalia√ß√µes da IA
window.pieceValues = window.pieceValues || { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 0 };
// Caminho configur√°vel para o arquivo WASM do Stockfish (usado pelo worker)
// Usar build multi-parte por padr√£o para m√°xima for√ßa (carregada via stockfish.js)
window.sfWasmFile = window.sfWasmFile || '__multipart__';
window.sfWasmOrigin = window.sfWasmOrigin || (location && location.origin ? location.origin : '');
// Cria√ß√£o robusta de Web Worker com fallbacks
async function ensureAIWorker(){
  if(aiWorker) return aiWorker;
  // Tentativa padr√£o
  try{ aiWorker = new Worker('ai-worker.js'); return aiWorker; }catch(_){ aiWorker=null; }
  // Fallback: Blob com importScripts (funciona em HTTP mesmo que o arquivo esteja separado)
  try{
    const blob = new Blob(["importScripts('ai-worker.js');"], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    aiWorker = new Worker(url);
    return aiWorker;
  }catch(_){ aiWorker=null; }
  // Fallback: incorporar c√≥digo via fetch e criar Blob
  try{
    const res = await fetch('ai-worker.js');
    if(res && res.ok){
      const txt = await res.text();
      const blob = new Blob([txt], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      aiWorker = new Worker(url);
      return aiWorker;
    }
  }catch(_){ aiWorker=null; }
  return null;
}

async function ensureSfWorker(){
  if(sfWorker) return sfWorker;
  
  // Criar via URL absoluta e enviar configura√ß√£o ao worker
  try{
    const wasmFile = String(window.sfWasmFile || 'stockfish.wasm');
    const wasmOrigin = String(window.sfWasmOrigin || (location && location.origin ? location.origin : ''));
    // Prefetch dos bytes do WASM no thread principal para evitar resolu√ß√£o incorreta dentro do Worker
    let wasmBytes = null;
    async function tryFetchBinary(url){
      try { const res = await fetch(url, { method: 'GET' }); if(res && res.ok){ return await res.arrayBuffer(); } }
      catch(e){ /* silencioso */ }
      return null;
    }
    // Tenta em ordem: valor configurado, relativo padr√£o, absoluto pela origem e fallback com barra
    const candidates = [
      wasmFile,
      'stockfish.wasm',
      (wasmOrigin ? wasmOrigin.replace(/\/$/, '') + '/' + wasmFile.replace(/^\//,'') : wasmFile),
      ('/' + wasmFile.replace(/^\//,''))
    ];
    if (wasmFile !== '__multipart__') {
      for(const url of candidates){
        const ab = await tryFetchBinary(url);
        if(ab){ wasmBytes = ab; break; }
      }
      if(!wasmBytes){ console.warn('N√£o foi poss√≠vel obter bytes do WASM via GET em nenhum caminho:', candidates); }
    }
    const sfWorkerAbs = (location && location.origin ? location.origin.replace(/\/$/, '') + '/sf-worker.js?v=' + Date.now() : 'sf-worker.js?v=' + Date.now());
    sfWorker = new Worker(sfWorkerAbs);
    try { 
      const cfg = { sfWasmFile: wasmFile, sfWasmOrigin: wasmOrigin, useBook: false, hashMb: 512, threads: 1, contempt: 0, moveOverhead: 100, ponder: false, multipv: 1, skill: 20, limitStrength: false };
      if (wasmBytes) {
        // Enviar ArrayBuffer como transfer√≠vel para evitar c√≥pia
        sfWorker.postMessage({ __cfg: { ...cfg, wasmBytes } }, [ wasmBytes ]);
      } else {
        sfWorker.postMessage({ __cfg: cfg });
      }
    } catch(_){}
    return sfWorker;
  }catch(_){ sfWorker=null; }
  // Fallback direto
  try{ sfWorker = new Worker('sf-worker.js'); return sfWorker; }catch(_){ sfWorker=null; }
  try{
    const blob = new Blob(["importScripts('sf-worker.js');"], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    sfWorker = new Worker(url);
    return sfWorker;
  }catch(_){ sfWorker=null; }
  try{
    const res = await fetch('sf-worker.js');
    if(res && res.ok){
      const txt = await res.text();
      const blob = new Blob([txt], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      sfWorker = new Worker(url);
      return sfWorker;
    }
  }catch(_){ sfWorker=null; }
  return null;
}
// Perfis de IA e placar persistente
const aiProfiles={"Arara (M√©dio)":"medio","On√ßa (Dif√≠cil)":"dificil","Tucano (F√°cil)":"facil","Tal (Agressivo)":"tal"};
let aiWhiteName='Arara (M√©dio)', aiBlackName='On√ßa (Dif√≠cil)';
let aiScores = JSON.parse(localStorage.getItem('chess_ai_scores')||'{}');
function saveScores(){ try{ localStorage.setItem('chess_ai_scores', JSON.stringify(aiScores)); }catch(_){}}
function renderScore(){ try{ const el=document.getElementById('aiScore'); if(!el) return; const entries=Object.entries(aiScores).sort((a,b)=>((b[1]?.wins||0)-(a[1]?.wins||0))); el.textContent = entries.length? entries.map(([n,s])=>`${n}: ${s.wins||0} vit√≥rias, ${s.draws||0} empates`).join(' | '): 'Placar IA vazio'; }catch(_){} }
const aiWhiteLabel=document.getElementById('aiWhiteLabel');const aiBlackLabel=document.getElementById('aiBlackLabel');
const aiWhiteNameSelect=document.getElementById('aiWhiteName');const aiBlackNameSelect=document.getElementById('aiBlackName');
const startAvaBtn=document.getElementById('startAva');
function populateAISelects(){ if(!aiWhiteNameSelect||!aiBlackNameSelect) return; const names=Object.keys(aiProfiles); aiWhiteNameSelect.innerHTML=''; aiBlackNameSelect.innerHTML=''; names.forEach(n=>{ const o1=document.createElement('option'); o1.value=n; o1.textContent=n; aiWhiteNameSelect.appendChild(o1); const o2=document.createElement('option'); o2.value=n; o2.textContent=n; aiBlackNameSelect.appendChild(o2); }); aiWhiteNameSelect.value=aiWhiteName; aiBlackNameSelect.value=aiBlackName; aiWhiteNameSelect.onchange=()=>{ aiWhiteName=aiWhiteNameSelect.value; renderScore(); }; aiBlackNameSelect.onchange=()=>{ aiBlackName=aiBlackNameSelect.value; renderScore(); }; }
function toggleAIFields(){ try{ const levelEl=document.getElementById('level'); const levelLabel=levelEl?levelEl.parentElement:null; if(mode==='ava'){ if(levelLabel) levelLabel.style.display='none'; if(aiWhiteLabel) aiWhiteLabel.style.display='flex'; if(aiBlackLabel) aiBlackLabel.style.display='flex'; if(aiWhiteNameSelect) aiWhiteNameSelect.style.display='inline'; if(aiBlackNameSelect) aiBlackNameSelect.style.display='inline'; if(startAvaBtn) startAvaBtn.style.display='inline'; } else { if(levelLabel) levelLabel.style.display='flex'; if(aiWhiteLabel) aiWhiteLabel.style.display='none'; if(aiBlackLabel) aiBlackLabel.style.display='none'; if(aiWhiteNameSelect) aiWhiteNameSelect.style.display='none'; if(aiBlackNameSelect) aiBlackNameSelect.style.display='none'; if(startAvaBtn) startAvaBtn.style.display='none'; } }catch(_){} }

  // Exibir seletores de motor quando houver IA
  (function(){
    const ui=document.getElementById('ui'); if(!ui) return;
  // Brancas
  if(!document.getElementById('engineWhiteLabel')){
    const lab=document.createElement('label'); lab.id='engineWhiteLabel'; lab.style.display='none';
    lab.append(document.createTextNode('Motor Brancas: '));
    const sel=document.createElement('select'); sel.id='engineWhite';
    ['tal','stockfish'].forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=(v==='tal'?'Tal':'Stockfish'); sel.appendChild(o); });
    sel.value = window.engineWhite || 'stockfish';
    sel.onchange = ()=>{ window.engineWhite = sel.value; };
    lab.appendChild(sel); ui.appendChild(lab);
  }
  // Pretas
  if(!document.getElementById('engineBlackLabel')){
    const lab=document.createElement('label'); lab.id='engineBlackLabel'; lab.style.display='none';
    lab.append(document.createTextNode('Motor Pretas: '));
    const sel=document.createElement('select'); sel.id='engineBlack';
    ['tal','stockfish'].forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=(v==='tal'?'Tal':'Stockfish'); sel.appendChild(o); });
    sel.value = window.engineBlack || 'stockfish';
    sel.onchange = ()=>{ window.engineBlack = sel.value; };
    lab.appendChild(sel); ui.appendChild(lab);
  }
  // Indicador fixo do motor ativo
  if(!document.getElementById('aiEngineInfo')){
    const info=document.createElement('div'); info.id='aiEngineInfo'; info.style.marginTop='6px'; info.style.fontSize='13px'; info.style.opacity='0.85';
    ui.appendChild(info);
  }
  function syncEngineSelectors(){
    const wLab=document.getElementById('engineWhiteLabel');
    const bLab=document.getElementById('engineBlackLabel');
    const wTimeLab=document.getElementById('sfTimeWhiteLabel');
    const bTimeLab=document.getElementById('sfTimeBlackLabel');
    const show = (mode==='ai' || mode==='ava');
    if(wLab) wLab.style.display = show ? 'flex' : 'none';
    if(bLab) bLab.style.display = show ? 'flex' : 'none';
    
    // Mostrar controles de tempo apenas quando Stockfish estiver selecionado
    const wEngine = document.getElementById('engineWhite');
    const bEngine = document.getElementById('engineBlack');
    if(wTimeLab) wTimeLab.style.display = (show && wEngine && wEngine.value === 'stockfish') ? 'flex' : 'none';
    if(bTimeLab) bTimeLab.style.display = (show && bEngine && bEngine.value === 'stockfish') ? 'flex' : 'none';

    // Ocultar seletor de n√≠vel quando o motor ativo for Stockfish
    const levelEl=document.getElementById('level'); const levelLabel=levelEl?levelEl.parentElement:null;
    if(levelLabel){
      if(mode==='ava'){ levelLabel.style.display='none'; }
      else if(mode==='ai'){
        const aiIsSF = (bEngine && bEngine.value==='stockfish');
        levelLabel.style.display = aiIsSF ? 'none' : 'flex';
      } else {
        levelLabel.style.display='flex';
      }
    }

    // Atualizar indicador do motor ativo
    const info=document.getElementById('aiEngineInfo');
    if(info){
      if(mode==='ai'){
        const side='Pretas';
        const eng = (bEngine && bEngine.value) ? bEngine.value : 'stockfish';
        const isSF = (eng==='stockfish');
        const timeMs = isSF ? (window.sfTimeMsBlack||15000) : thinkDelay();
        info.textContent = `IA ativa: ${side} ‚Ä¢ ${isSF?'Stockfish':'Tal'} ‚Ä¢ Tempo: ${Math.round(timeMs/1000)}s`;
      } else if(mode==='ava'){
        const engW = (wEngine && wEngine.value) ? wEngine.value : 'stockfish';
        const engB = (bEngine && bEngine.value) ? bEngine.value : 'stockfish';
        const tW = (engW==='stockfish') ? (window.sfTimeMsWhite||15000) : thinkDelay();
        const tB = (engB==='stockfish') ? (window.sfTimeMsBlack||15000) : thinkDelay();
        info.textContent = `IA vs IA ‚Ä¢ Brancas: ${engW==='stockfish'?'Stockfish':'Tal'} (${Math.round(tW/1000)}s) ‚Ä¢ Pretas: ${engB==='stockfish'?'Stockfish':'Tal'} (${Math.round(tB/1000)}s)`;
      } else {
        info.textContent = '';
      }
    }
  }
  // inicial e nos eventos
  syncEngineSelectors();
  const modeEl=document.getElementById('mode');
  if(modeEl){ modeEl.addEventListener('change', syncEngineSelectors); }
  
  // Atualizar visibilidade dos controles de tempo quando o motor muda
  const wEngine = document.getElementById('engineWhite');
  const bEngine = document.getElementById('engineBlack');
  if(wEngine) wEngine.addEventListener('change', syncEngineSelectors);
  if(bEngine) bEngine.addEventListener('change', syncEngineSelectors);
})();
// Estado global de motor por lado
window.engineWhite = window.engineWhite || 'stockfish';
window.engineBlack = window.engineBlack || 'stockfish';
document.getElementById('mode').onchange=e=>{ mode=e.target.value; toggleAIFields(); };
// For√ßar Stockfish para Pretas ao entrar em Jogador vs IA
(function(){
  const modeEl=document.getElementById('mode');
  if(modeEl){
    const enforce=()=>{
      if(mode==='ai'){
        window.engineBlack = 'stockfish';
        const bSel=document.getElementById('engineBlack'); if(bSel) bSel.value='stockfish';
        // garantir visibilidade dos controles de tempo das Pretas
        const bTimeLab=document.getElementById('sfTimeBlackLabel'); if(bTimeLab) bTimeLab.style.display='flex';
      }
    };
    // aplicar ao carregar e em mudan√ßas
    try{ enforce(); }catch(_){}
    modeEl.addEventListener('change', ()=>{ mode=modeEl.value; enforce(); });
  }
})();

// Adicionar controles de tempo para Stockfish
(function(){
  const ui=document.getElementById('ui');
  if(ui && !document.getElementById('sfTimeWhiteLabel')){
    const lab=document.createElement('label'); lab.id='sfTimeWhiteLabel'; lab.style.display='none';
    lab.append(document.createTextNode('Tempo SF Brancas: '));
    const sel=document.createElement('select'); sel.id='sfTimeWhite';
    [500, 1000, 2000, 3000, 5000, 8000, 10000, 15000, 20000, 30000].forEach(v=>{ 
      const o=document.createElement('option'); 
      o.value=v; 
      o.textContent=`${v/1000}s`; 
      sel.appendChild(o); 
    });
    sel.value = window.sfTimeMsWhite || 15000;
sel.onchange = ()=>{ window.sfTimeMsWhite = parseInt(sel.value); };
    lab.appendChild(sel); ui.appendChild(lab);
  }
  if(ui && !document.getElementById('sfTimeBlackLabel')){
    const lab=document.createElement('label'); lab.id='sfTimeBlackLabel'; lab.style.display='none';
    lab.append(document.createTextNode('Tempo SF Pretas: '));
    const sel=document.createElement('select'); sel.id='sfTimeBlack';
    [500, 1000, 2000, 3000, 5000, 8000, 10000, 15000, 20000, 30000].forEach(v=>{ 
      const o=document.createElement('option'); 
      o.value=v; 
      o.textContent=`${v/1000}s`; 
      sel.appendChild(o); 
    });
    sel.value = window.sfTimeMsBlack || 15000;
sel.onchange = ()=>{ window.sfTimeMsBlack = parseInt(sel.value); };
    lab.appendChild(sel); ui.appendChild(lab);
  }
  
  // Sincronizar visibilidade dos controles de tempo
  function syncSfTime(){
    const showWhite = (mode!=='pvp') && (window.engineWhite==='stockfish');
    const showBlack = (mode!=='pvp') && (window.engineBlack==='stockfish');
    const wLab=document.getElementById('sfTimeWhiteLabel');
    const bLab=document.getElementById('sfTimeBlackLabel');
    if(wLab) wLab.style.display = showWhite ? 'flex' : 'none';
    if(bLab) bLab.style.display = showBlack ? 'flex' : 'none';
  }
  syncSfTime();
  const ew=document.getElementById('engineWhite');
  const eb=document.getElementById('engineBlack');
  if(ew) ew.addEventListener('change', syncSfTime);
  if(eb) eb.addEventListener('change', syncSfTime);
  // Bot√£o de preset "Poderos√≠ssimo": tempo 15s e reconfigura op√ß√µes fortes
  if(ui && !document.getElementById('sfPresetMax')){
    const btn=document.createElement('button'); btn.id='sfPresetMax'; btn.textContent='Preset: Poderos√≠ssimo'; btn.style.marginLeft='8px';
    btn.onclick=async ()=>{
      try{
        window.sfTimeMsWhite = 15000; window.sfTimeMsBlack = 15000;
        const wSel=document.getElementById('sfTimeWhite'); const bSel=document.getElementById('sfTimeBlack');
        if(wSel) wSel.value = String(window.sfTimeMsWhite);
        if(bSel) bSel.value = String(window.sfTimeMsBlack);
        const w = await ensureSfWorker();
        if(w){ w.postMessage({ __cfg: { hashMb: 512, multipv: 1, ponder: false, threads: 1, contempt: 0, moveOverhead: 100, skill: 20, limitStrength: false } }); }
        const ew=document.getElementById('engineWhite'); const eb=document.getElementById('engineBlack');
        if(ew) ew.dispatchEvent(new Event('change')); if(eb) eb.dispatchEvent(new Event('change'));
      }catch(_){ /* silencioso */ }
    };
    const wLab=document.getElementById('sfTimeWhiteLabel'); if(wLab) wLab.appendChild(btn);
  }
  // Bot√£o de preset "Ultra": tempo 30s, Hash 1024MB, Threads 2
  if(ui && !document.getElementById('sfPresetUltra')){
    const btnU=document.createElement('button'); btnU.id='sfPresetUltra'; btnU.textContent='Preset: Ultra'; btnU.style.marginLeft='8px';
    btnU.onclick=async ()=>{
      try{
        window.sfTimeMsWhite = 30000; window.sfTimeMsBlack = 30000;
        const wSel=document.getElementById('sfTimeWhite'); const bSel=document.getElementById('sfTimeBlack');
        if(wSel) wSel.value = String(window.sfTimeMsWhite);
        if(bSel) bSel.value = String(window.sfTimeMsBlack);
        const w = await ensureSfWorker();
        if(w){ w.postMessage({ __cfg: { hashMb: 1024, multipv: 1, ponder: false, threads: 2, contempt: 0, moveOverhead: 100, skill: 20, limitStrength: false } }); }
        const ew=document.getElementById('engineWhite'); const eb=document.getElementById('engineBlack');
        if(ew) ew.dispatchEvent(new Event('change')); if(eb) eb.dispatchEvent(new Event('change'));
      }catch(_){ /* silencioso */ }
    };
    const wLab=document.getElementById('sfTimeWhiteLabel'); if(wLab) wLab.appendChild(btnU);
  }
})();
document.getElementById('level').onchange=e=>{ level=e.target.value };
// Seletor de motor (Tal ou Stockfish)
const engineSel=document.getElementById('engine');
if(engineSel){
  // Padr√£o visual e l√≥gico: Stockfish
  if(!engineSel.value) engineSel.value = 'stockfish';
  window.engine = engineSel.value || 'stockfish';
  // Estado global de motor por lado
  window.engineWhite = window.engineWhite || 'stockfish';
  window.engineBlack = window.engineBlack || 'stockfish';
  engineSel.onchange = e => { 
    window.engine = e.target.value || 'stockfish'; 
    // Atualiza ambos os motores quando o seletor principal muda
    window.engineWhite = window.engine;
    window.engineBlack = window.engine;
  };
}
document.getElementById('reset').onclick=()=>{ init(); if(mode!=='ava'){ try{ startClock(); switchClock(); }catch(_){} } };
if(startAvaBtn){ startAvaBtn.onclick=()=>{ if(mode==='ava'){ init(); updateStatus(); try{ startClock(); switchClock(); }catch(_){} setTimeout(()=>{ try{ runAI(); }catch(_){} }, thinkDelay()); } }; }
populateAISelects(); toggleAIFields(); renderScore();
const btnDraw=document.getElementById('draw');
const btnResign=document.getElementById('resign');
if(btnDraw){ btnDraw.onclick=()=>{ 
  if(mode==='ai'){ playSound('draw'); endGame('Empate aceito'); return; }
  // PvP: alternar oferta de empate para o lado atual
  if(!drawOffer){ drawOffer=turn; updateStatus(); syncDrawButtons(); }
  else if(drawOffer && drawOffer!==turn){ // lado oposto aceitou
    playSound('draw'); endGame('Empate por acordo'); drawOffer=null; syncDrawButtons();
  } else { // mesmo lado clicou de novo -> cancela
    drawOffer=null; updateStatus(); syncDrawButtons();
  }
}; }
if(btnResign){ btnResign.onclick=()=>{
  const ok = confirm('Tem certeza que deseja desistir?');
  if(!ok) return;
  const winner = turn==='white' ? 'Pretas vencem por desist√™ncia' : 'Brancas vencem por desist√™ncia';
  playSound('resign');
  endGame(winner);
}; }
// Inicializa√ß√£o robusta do DOM
(function(){
  const start=()=>{ try{ init(); updateStatus(); if(mode!=='ava'){ try{ startClock(); switchClock(); }catch(_){} } }catch(e){ console.error(e); } };
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', start);
  else start();
})();
// Controle de volume global
const volEl=document.getElementById('vol'); let currentVol=1.0; if(volEl){ currentVol=Math.max(0,Math.min(1, volEl.value/100)); volEl.oninput=e=>{ currentVol=Math.max(0,Math.min(1, e.target.value/100)); }; }

// Orienta√ß√£o do tabuleiro (true = brancas em baixo)
let whiteBottom=true;
let lastAISrc=null;
// Adiciona bot√£o de girar na UI
const uiEl=document.getElementById('ui');
if(uiEl&&!document.getElementById('flip')){const flipBtn=document.createElement('button');flipBtn.id='flip';flipBtn.textContent='Girar';flipBtn.onclick=()=>{whiteBottom=!whiteBottom;render()};uiEl.appendChild(flipBtn)}

// Adicionar bot√µes Aceitar/Recusar para oferta de empate (PvP)
(function(){
  const uiEl=document.getElementById('ui');
  if(uiEl && !document.getElementById('drawAccept')){
    const acc=document.createElement('button'); acc.id='drawAccept'; acc.textContent='Aceitar'; acc.style.display='none'; uiEl.appendChild(acc);
    const dec=document.createElement('button'); dec.id='drawDecline'; dec.textContent='Recusar'; dec.style.display='none'; uiEl.appendChild(dec);
    acc.onclick=()=>{
      if(mode==='pvp' && drawOffer && drawOffer!==turn){ playSound('draw'); endGame('Empate por acordo'); drawOffer=null; syncDrawButtons(); }
    };
    dec.onclick=()=>{
      if(mode==='pvp' && drawOffer && drawOffer!==turn){ drawOffer=null; updateStatus(); syncDrawButtons(); }
    };
  }
})();
function syncDrawButtons(){
  const btnDraw=document.getElementById('draw');
  const acc=document.getElementById('drawAccept');
  const dec=document.getElementById('drawDecline');
  if(!btnDraw||!acc||!dec) return;
  if(mode==='pvp' && drawOffer){ btnDraw.style.display='none'; acc.style.display='inline-block'; dec.style.display='inline-block'; }
  else { btnDraw.style.display='inline-block'; acc.style.display='none'; dec.style.display='none'; }
}

// Rel√≥gios de Xadrez
let timeMode = 'blitz'; let tW=300, tB=300; let timer=null; let lastTick=null;
// en passant (quadrado alvo dispon√≠vel por um turno)
let enp=null; // {x,y,forColor}
// Aprendizado simples do Tal: helpers e log
let talMoveLog=[]; // [{fen, uci, color}] somente lances do Tal nas aberturas
// Debug de IA Tal
window.talDebug = false; // ative com: window.talDebug = true
function logTal(msg, data){ try{ if(window.talDebug) console.debug('[Tal]', msg, data||''); }catch(_){ /* silencioso */ } }
function sq(x,y){ return 'abcdefgh'[x] + (y+1); }
function loadTalLearn(){ try{ const raw=localStorage.getItem('talLearn'); return raw? JSON.parse(raw) : { book: {}, perf: {} }; }catch(_){ return { book: {}, perf: {} }; } }
function saveTalLearn(d){ try{ localStorage.setItem('talLearn', JSON.stringify(d)); }catch(_){} }
function pieceToFENChar(p){ if(!p) return null; const ch=p.t; return p.c==='white'? ch : ch.toLowerCase(); }
function toFEN(s, side){
  const ranks=[];
  for(let y=7;y>=0;y--){ let run=0, rank=''; for(let x=0;x<8;x++){ const ch=pieceToFENChar(s[y][x]); if(!ch){ run++; } else { if(run>0){ rank+=String(run); run=0; } rank+=ch; } } if(run>0) rank+=String(run); ranks.push(rank); }
  const board=ranks.join('/');
  const active = side==='black' ? 'b' : 'w';
  const castle = getCastleRights(s);
  const ep = enp ? String.fromCharCode(97 + enp.x) + String(enp.y + 1) : '-';
  return `${board} ${active} ${castle} ${ep} 0 1`;
}
function uciFromMove(x,y,m){ const fx=String.fromCharCode(97+x); const fy=String(y+1); const tx=String.fromCharCode(97+m.x); const ty=String(m.y+1); const promo=m.promote? String(m.promote).toLowerCase() : ''; return fx+fy+tx+ty+promo; }
// Regras de empate: rel√≥gio de 50 lances e repeti√ß√£o de posi√ß√£o
let halfmoveClock=0; // conta meias-jogadas desde √∫ltima captura ou movimento de pe√£o
let posCounts={}; // mapa de posi√ß√µes para tripla repeti√ß√£o
 let drawOffer=null; // oferta de empate atual ('white' ou 'black')
 const clockWEl = document.getElementById('clockW');
const clockBEl = document.getElementById('clockB');
const timeSel = document.getElementById('time');
if(timeSel){ timeSel.onchange = e=>{ timeMode=e.target.value; setupTime(); resetClockUI(); } }

function setupTime(){
  if(timeMode==='classica'){ tW=tB=60*60; }
  else if(timeMode==='rapida'){ tW=tB=15*60; }
  else if(timeMode==='blitz'){ tW=tB=5*60; }
  else { tW=tB=60; }
}
function format(t){ const m=Math.floor(t/60); const s=Math.floor(Math.max(0,t%60)); return String(m).padStart(2,'0')+":"+String(s).padStart(2,'0'); }
function resetClockUI(){ if(clockWEl) clockWEl.textContent=format(tW); if(clockBEl) clockBEl.textContent=format(tB); }
function initClock(){ setupTime(); resetClockUI(); if(timer){clearInterval(timer); timer=null;} lastTick=null; }
function startClock(){ if(timer) return; lastTick=Date.now(); timer=setInterval(tick, 200); }
function stopClock(){ if(timer){ clearInterval(timer); timer=null; } }
function switchClock(){ lastTick=Date.now(); }
function tick(){
  if(!lastTick) return;
  const now=Date.now();
  const dt=(now-lastTick)/1000; // segundos fracion√°rios
  lastTick=now;
  if(turn==='white'){
    tW=Math.max(0,tW-dt);
    if(clockWEl) clockWEl.textContent=format(tW);
    if(tW<=0) timeOver('white');
  }else{
    tB=Math.max(0,tB-dt);
    if(clockBEl) clockBEl.textContent=format(tB);
    if(tB<=0) timeOver('black');
  }
}
function timeOver(color){
  const winner = (color==='white') ? 'Pretas vencem por tempo' : 'Brancas vencem por tempo';
  endGame('Tempo esgotado! '+winner);
}
function init(){enp=null;halfmoveClock=0;posCounts={};drawOffer=null;moveHistory=[];fullmoveNumber=1;gameResult='*';lastAISrc=null;g=[...Array(8)].map(_=>Array(8).fill(null));turn='white';// pe√ßas
for(let x=0;x<8;x++){g[1][x]={t:'P',c:'white',m:false};g[6][x]={t:'P',c:'black',m:false} }
[['R','N','B','Q','K','B','N','R']].forEach(arr=>{for(let x=0;x<8;x++)g[0][x]={t:arr[x],c:'white',m:false};for(let x=0;x<8;x++)g[7][x]={t:arr[x],c:'black',m:false} });render();updTurn();initClock();recordPosition();syncDrawButtons();renderMoves();
}
function render(){
  bd.innerHTML='';
  for(let yd=0;yd<8;yd++){
    for(let xd=0;xd<8;xd++){
      const x = whiteBottom ? xd : 7 - xd;
      const y = whiteBottom ? 7 - yd : yd;
      const d=document.createElement('div');
      d.className='sq '+(((xd+yd)%2)?'d':'l');
      d.dataset.x=x; d.dataset.y=y;
      const p=g[y][x];
      if(p){
        const color=(p.c==='white'?'#f9fafb':'#111827');
        const shadow=(p.c==='white'?'text-shadow:0 0 2px #000;':'');
        d.innerHTML='<span style="color:'+color+';'+shadow+'">'+U[p.c][p.t]+'</span>';
      }
      bd.appendChild(d);
    }
  }
  doHighlight();
  const humanTurn = (mode==='pvp') || (mode==='ai' && turn==='white');
  bd.querySelectorAll('.sq').forEach(s=>{ s.onclick = humanTurn ? onClick : null; s.style.cursor = humanTurn ? 'pointer' : 'default'; });
}
function doHighlight(){
  if(sel){
    const el = bd.querySelector('.sq[data-x="'+sel.x+'"][data-y="'+sel.y+'"]');
    if(el) el.classList.add('sel');
  }
  for(const m of opts){
    const el = bd.querySelector('.sq[data-x="'+m.x+'"][data-y="'+m.y+'"]');
    if(el) el.classList.add('opt');
  }
}
function updTurn(){document.getElementById('turn').textContent='Turno: '+(turn==='white'?'Branco':'Preto')}
function onClick(e){const x=+e.currentTarget.dataset.x,y=+e.currentTarget.dataset.y,p=g[y][x];if(sel){const mv=opts.find(m=>m.x===x&&m.y===y);if(mv)return doMove(sel.x,sel.y,mv);sel=null;opts=[];render();return}if(p&&p.c===turn){sel={x,y};opts=legalMoves(x,y);render()}}
function inB(x,y){return x>=0&&x<8&&y>=0&&y<8}
function legalMoves(x,y){const p=g[y][x];let ms=pseudoMoves(x,y);return ms.filter(m=>legalAfter(x,y,m))}
function pseudoMoves(x,y){const p=g[y][x],ms=[];if(!p)return ms;const add=(nx,ny)=>{if(!inB(nx,ny))return;const q=g[ny][nx];if(!q)ms.push({x:nx,y:ny});else if(q.c!==p.c)ms.push({x:nx,y:ny,cap:true})};if(p.t==='N'){for(const [dx,dy] of [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]])add(x+dx,y+dy)}else if(p.t==='B'||p.t==='R'||p.t==='Q'){const dirs=[];if(p.t!=='R')dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);if(p.t!=='B')dirs.push([1,0],[-1,0],[0,1],[0,-1]);for(const [dx,dy]of dirs){let nx=x+dx,ny=y+dy;while(inB(nx,ny)&&!g[ny][nx]){ms.push({x:nx,y:ny});nx+=dx;ny+=dy}if(inB(nx,ny)&&g[ny][nx]&&g[ny][nx].c!==p.c)ms.push({x:nx,y:ny,cap:true})}}else if(p.t==='K'){
    for(const [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]) add(x+dx,y+dy);
    // roque
    const hasMoved = !!p.m; const rank=y;
    if(!hasMoved && x===4 && (rank===0||rank===7) && !isCheck(g,p.c)){
      // pequeno (rei para g, torre h->f)
      const rookK=g[rank][7];
      if(rookK && rookK.t==='R' && rookK.c===p.c && !rookK.m){
        if(!g[rank][5] && !g[rank][6] && !attacked(g,p.c,5,rank) && !attacked(g,p.c,6,rank)) ms.push({x:6,y:rank,castle:'K'});
      }
      // grande (rei para c, torre a->d)
      const rookQ=g[rank][0];
      if(rookQ && rookQ.t==='R' && rookQ.c===p.c && !rookQ.m){
        if(!g[rank][1] && !g[rank][2] && !g[rank][3] && !attacked(g,p.c,3,rank) && !attacked(g,p.c,2,rank)) ms.push({x:2,y:rank,castle:'Q'});
      }
    }
  }else if(p.t==='P'){
    const dir=p.c==='white'?1:-1;
    // capturas normais + en passant
    for(const dx of[-1,1]){
      const cx=x+dx,cy=y+dir;
      if(inB(cx,cy)&&g[cy][cx]&&g[cy][cx].c!==p.c) ms.push({x:cx,y:cy,cap:true});
      // en passant
      if(enp && enp.forColor===p.c && enp.x===cx && enp.y===cy){
        if(inB(cx,y)&&g[y][cx]&&g[y][cx].t==='P'&&g[y][cx].c!==p.c){
          ms.push({x:cx,y:cy,cap:true,ep:true});
        }
      }
    }
    // avan√ßo simples/duplo
    const nx=x,ny=y+dir; if(inB(nx,ny)&&!g[ny][nx]){ ms.push({x:nx,y:ny}); const sy=p.c==='white'?1:6; const ny2=y+2*dir; if(y===sy&&inB(nx,ny2)&&!g[ny2][nx]&&!g[ny][nx]) ms.push({x:nx,y:ny2}); }
  }
  return ms}
function legalAfter(x,y,m){const s=clone(g);apply(s,x,y,m);return !isCheck(s,turn)}
function isCheck(s,color){let kx=-1,ky=-1;for(let y=0;y<8;y++)for(let x=0;x<8;x++){const p=s[y][x];if(p&&p.c===color&&p.t==='K'){kx=x;ky=y}}const opp=color==='white'?'black':'white';// gerar ataques do oponente
for(let y=0;y<8;y++)for(let x=0;x<8;x++){
  const p=s[y][x];
  if(!p||p.c!==opp) continue;
  let at=pseudoOn(s,x,y);
  if(p.t==='P') at = at.filter(m=>m.cap); // pe√µes s√≥ atacam nas diagonais
  if(at.some(m=>m.x===kx&&m.y===ky)) return true
}return false}
function attacked(s,color,x,y){
  const opp = color==='white'?'black':'white';
  for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++){
    const p=s[yy][xx]; if(!p||p.c!==opp) continue;
    let at=[];
    if(p.t==='K'){
      // rei ataca as 8 adjacentes; n√£o considera roque
      for(const [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=xx+dx, ny=yy+dy; if(inB(nx,ny)) at.push({x:nx,y:ny});
      }
    }else{
      at = pseudoOn(s,xx,yy);
      at = at.filter(m=>!m.castle);
      if(p.t==='P') at = at.filter(m=>m.cap);
    }
    if(at.some(m=>m.x===x && m.y===y)) return true;
  }
  return false;
}
function pseudoOn(s,x,y){
  const p=s[y][x],ms=[]; if(!p) return ms;
  const add=(nx,ny)=>{ if(!inB(nx,ny)) return; const q=s[ny][nx]; if(!q) ms.push({x:nx,y:ny}); else if(q.c!==p.c) ms.push({x:nx,y:ny,cap:true}); };
  if(p.t==='N'){
    for(const[dx,dy]of[[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]]) add(x+dx,y+dy);
  }else if(p.t==='B'||p.t==='R'||p.t==='Q'){
    const dirs=[]; if(p.t!=='R') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]); if(p.t!=='B') dirs.push([1,0],[-1,0],[0,1],[0,-1]);
    for(const[dx,dy]of dirs){ let nx=x+dx, ny=y+dy; while(inB(nx,ny)&&!s[ny][nx]){ ms.push({x:nx,y:ny}); nx+=dx; ny+=dy; } if(inB(nx,ny)&&s[ny][nx]&&s[ny][nx].c!==p.c) ms.push({x:nx,y:ny,cap:true}); }
  }else if(p.t==='K'){
    // Rei: apenas casas adjacentes. Roque ser√° tratado em legalOn para evitar recurs√£o com isCheck
    for(const[dx,dy]of[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]) add(x+dx,y+dy);
  }else if(p.t==='P'){
    const dir=p.c==='white'?1:-1; for(const dx of[-1,1]){ const cx=x+dx, cy=y+dir; if(inB(cx,cy)&&s[cy][cx]&&s[cy][cx].c!==p.c) ms.push({x:cx,y:cy,cap:true}); if(enp && enp.forColor===p.c && enp.x===cx && enp.y===cy){ if(inB(cx,y)&&s[y][cx]&&s[y][cx].t==='P'&&s[y][cx].c!==p.c){ ms.push({x:cx,y:cy,cap:true,ep:true}); } } }
    const nx=x,ny=y+dir; if(inB(nx,ny)&&!s[ny][nx]) ms.push({x:nx,y:ny}); const sy=p.c==='white'?1:6; const ny2=y+2*dir; if(y===sy&&inB(nx,ny2)&&!s[ny2][nx]&&!s[ny][nx]) ms.push({x:nx,y:ny2});
  }
  return ms;
}
function legalAfter(x,y,m){const s=clone(g);apply(s,x,y,m);return !isCheck(s,turn)}
function isCheck(s,color){let kx=-1,ky=-1;for(let y=0;y<8;y++)for(let x=0;x<8;x++){const p=s[y][x];if(p&&p.c===color&&p.t==='K'){kx=x;ky=y}}const opp=color==='white'?'black':'white';// gerar ataques do oponente
for(let y=0;y<8;y++)for(let x=0;x<8;x++){
  const p=s[y][x];
  if(!p||p.c!==opp) continue;
  let at=pseudoOn(s,x,y);
  if(p.t==='P') at = at.filter(m=>m.cap); // pe√µes s√≥ atacam nas diagonais
  if(at.some(m=>m.x===kx&&m.y===ky)) return true
}return false}
function attacked(s,color,x,y){
  const opp = color==='white'?'black':'white';
  for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++){
    const p=s[yy][xx]; if(!p||p.c!==opp) continue;
    let at=[];
    if(p.t==='K'){
      // rei ataca as 8 adjacentes; n√£o considera roque
      for(const [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=xx+dx, ny=yy+dy; if(inB(nx,ny)) at.push({x:nx,y:ny});
      }
    }else{
      at = pseudoOn(s,xx,yy);
      at = at.filter(m=>!m.castle);
      if(p.t==='P') at = at.filter(m=>m.cap);
    }
    if(at.some(m=>m.x===x && m.y===y)) return true;
  }
  return false;
}

function apply(s,x,y,m){const p=s[y][x];s[y][x]=null;// en passant captura: remover pe√£o capturado atr√°s do alvo
if(m.ep){ const dir = (p.c==='white'?1:-1); const cy=m.y - dir; const cx=m.x; if(s[cy][cx] && s[cy][cx].t==='P') s[cy][cx]=null; }
// aplicar movimento/roque
if(m.castle){
  s[m.y][m.x]=p; if(s[m.y][m.x]) s[m.y][m.x].m=true;
  if(m.castle==='K'){
    const r=s[m.y][7]; s[m.y][7]=null; s[m.y][5]=r; if(s[m.y][5]) s[m.y][5].m=true;
  }else if(m.castle==='Q'){
    const r=s[m.y][0]; s[m.y][0]=null; s[m.y][3]=r; if(s[m.y][3]) s[m.y][3].m=true;
  }
}else{
  s[m.y][m.x]=p; if(s[m.y][m.x]) s[m.y][m.x].m=true;
}
// promo√ß√£o (suporta escolha via m.promote)
if(p.t==='P' && ((p.c==='white'&&m.y===7) || (p.c==='black'&&m.y===0))){
  const tp = m.promote || 'Q'; s[m.y][m.x] = {t:tp, c:p.c};
}
}

// Sons (Web Audio)
let AC=null;
function getAC(){try{if(!AC) AC=new (window.AudioContext||window.webkitAudioContext)();}catch(e){} return AC;}
function beep(freq=440,duration=0.08,type='sine',vol=0.1){const ac=getAC();if(!ac) return; const osc=ac.createOscillator(); const gain=ac.createGain(); osc.type=type; osc.frequency.value=freq; const v = Math.max(0, (typeof currentVol!=='undefined'?currentVol:1) * vol); gain.gain.value=v; osc.connect(gain); gain.connect(ac.destination); const now=ac.currentTime; osc.start(now); osc.stop(now+duration);} 
function playSound(kind){
  const chk=document.getElementById('snd');if(!chk||!chk.checked) return;
  if(kind==='move') beep(420,0.06,'sine',0.12);
  else if(kind==='cap') beep(240,0.08,'square',0.15);
  else if(kind==='chk') beep(700,0.15,'triangle',0.18);
  else if(kind==='mate') beep(900,0.25,'sawtooth',0.2);
  else if(kind==='draw') beep(520,0.18,'sine',0.16);
  else if(kind==='resign') beep(300,0.22,'square',0.18);
} 

// Gera um pequeno PNG (via canvas) para indicar jogada de livro
function ensureBookPng(){
  try{
    if(window.bookPngUrl) return;
    const c=document.createElement('canvas'); c.width=24; c.height=16;
    const ctx=c.getContext('2d');
    // fundo
    ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,c.width,c.height);
    // capa do livro
    ctx.fillStyle='#1f7a1f'; ctx.fillRect(2,2,20,12);
    // lombada
    ctx.fillStyle='#145214'; ctx.fillRect(2,2,4,12);
    // marca p√°gina
    ctx.fillStyle='#ffcc00'; ctx.beginPath(); ctx.moveTo(16,2); ctx.lineTo(16,9); ctx.lineTo(12,7); ctx.closePath(); ctx.fill();
    // linhas simulando p√°ginas
    ctx.strokeStyle='#e8f5e8'; ctx.lineWidth=1; for(let y=4;y<=12;y+=2){ ctx.beginPath(); ctx.moveTo(6,y); ctx.lineTo(20,y); ctx.stroke(); }
    window.bookPngUrl=c.toDataURL('image/png');
  }catch(_){ /* silencioso */ }
}

function updateStatus(){
  const el=document.getElementById('status');
  const color=turn;
  // limpar destaques anteriores
  if(typeof bd!=='undefined' && bd && bd.children){for(let i=0;i<bd.children.length;i++){bd.children[i].style.outline='';bd.children[i].style.boxShadow='';}}
  const s=clone(g);
  
  // Indicador do motor que jogou o √∫ltimo lance
  let engineInfo = '';
  if(window.lastAISrc && window.lastAISrc !== null) {
    const engineName = window.lastAISrc === 'book' ? 'üìò Livro' :
                      window.lastAISrc === 'stockfish' ? 'ü§ñ Stockfish' : 
                      window.lastAISrc === 'tal' ? 'üß† Tal' : 
                      window.lastAISrc === 'med' ? 'üéØ IA M√©dio' : 
                      window.lastAISrc === 'easy' ? 'üé≤ IA F√°cil' : 
                      `üîß ${window.lastAISrc}`;
    const prevColor = turn === 'white' ? 'Pretas' : 'Brancas';
    const isBook = (window.lastAISrc === 'book');
    let imgHtml = '';
    if(isBook){ ensureBookPng(); if(window.bookPngUrl){ imgHtml = ` <img src="${window.bookPngUrl}" alt="Livro" title="Jogada de livro" style="height:16px; vertical-align:middle; margin-left:6px">`; } }
    engineInfo = ` ‚Ä¢ √öltimo lance: ${prevColor} (${engineName})${imgHtml}`;
  }
  
  if(isCheck(s,color)){
    el.innerHTML='Xeque ao '+(color==='white'?'Branco':'Preto')+'!' + engineInfo;
    playSound('chk');
    // destacar rei em xeque
    let kx=-1,ky=-1;for(let y=0;y<8;y++)for(let x=0;x<8;x++){const p=s[y][x];if(p&&p.c===color&&p.t==='K'){kx=x;ky=y}}
    if(kx>=0&&ky>=0&&bd){const elK=bd.querySelector('.sq[data-x="'+kx+'"][data-y="'+ky+'"]');if(elK){elK.style.outline='3px solid #ef4444';elK.style.boxShadow='0 0 6px #ef4444';}}
  }else{
     el.innerHTML = engineInfo;
   }
   // Exibir oferta de empate se houver e n√£o estiver em xeque
   if(drawOffer && !isCheck(s,color)){
     const side = drawOffer==='white' ? 'Brancas' : 'Pretas';
     el.innerHTML = side + ' oferecem empate' + engineInfo;
   }
   syncDrawButtons();
   // Cheque-mate / afogamento
   const ms=allLegal(g,turn);
   if(ms.length===0){
     if(isCheck(g,turn)){
       endGame('Xeque-mate! '+(turn==='white'?'Pretas vencem':'Brancas vencem'));
       playSound('mate');
     }else{
       endGame('Empate por afogamento (sem movimentos)');
     }
   }
 }
function clone(s){return s.map(r=>r.map(c=>c?{t:c.t,c:c.c,m:c.m}:null))}

// UI de promo√ß√£o simples
let pendingMove=null;
function needPromotion(p,m){return p && p.t==='P' && ((p.c==='white'&&m.y===7)||(p.c==='black'&&m.y===0));}
function createPromoUI(){ if(document.getElementById('promo')) return; const d=document.createElement('div'); d.id='promo'; d.style.textAlign='center'; d.style.margin='8px'; d.style.display='none'; d.innerHTML='Promover para: <button data-p="Q">Dama</button> <button data-p="R">Torre</button> <button data-p="B">Bispo</button> <button data-p="N">Cavalo</button>'; const boardEl=document.getElementById('board'); if(boardEl && boardEl.parentNode){ boardEl.parentNode.insertBefore(d, boardEl); } else { document.body.appendChild(d); } }
function showPromo(onPick){ createPromoUI(); const d=document.getElementById('promo'); d.style.display='block'; ['Q','R','B','N'].forEach(t=>{ const btn=d.querySelector('button[data-p="'+t+'"]'); if(btn) btn.onclick=()=>{ d.style.display='none'; onPick(t); }; }); }

function execMove(x,y,m){
  if(typeof x!=='number' || typeof y!=='number' || !inB(x,y)) { console.warn('Ignorando movimento: origem fora dos limites em execMove', {x,y,m}); return; }
  if(!m || typeof m.x!=='number' || typeof m.y!=='number' || !inB(m.x,m.y)) { console.warn('Ignorando movimento: destino fora dos limites em execMove', {x,y,m}); return; }
  const p = g[y] && g[y][x];
  if(!p){ 
    console.warn('Ignorando movimento: origem vazia em execMove', {x,y,m}); 
    return; 
  }

  const capture = !!m.cap;
  const s0 = clone(g); // estado antes do movimento para SAN
  const san = toSAN(s0, x, y, m);

  // en passant anterior expira
  enp = null;

  // aplica no tabuleiro
  apply(g, x, y, m);

  // registrar SAN + origem da IA (se aplic√°vel), baseado na cor do movedor antes do apply
  const moverColor = p.c;
  const isAITurn = (mode==='ava') || (mode==='ai' && moverColor==='black');
  const srcTag = isAITurn ? lastAISrc : null;
  // log para livro pessoal do Tal (apenas primeiros lances)
  try{
    if(isAITurn && levelFor(moverColor)==='tal'){
      const fen=toFEN(s0, moverColor);
      const uci=uciFromMove(x,y,m);
      // Aprender tamb√©m em finais: registra sempre quando poucas pe√ßas
      let pcs=0; for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++) if(s0[yy][xx]) pcs++;
      if(talMoveLog.length<16 || pcs<=10){ talMoveLog.push({ fen, uci, color: moverColor }); }
    }
  }catch(_){ /* silencioso */ }

  if(moverColor==='white'){
    moveHistory.push({num:fullmoveNumber, w: san, wsrc: srcTag});
  } else {
    if(moveHistory.length===0) moveHistory.push({num:fullmoveNumber, w: '...'});
    moveHistory[moveHistory.length-1].b = san;
    moveHistory[moveHistory.length-1].bsrc = srcTag;
    fullmoveNumber++;
  }

  // limpa origem ap√≥s registrar
  lastAISrc = null;

  renderMoves();
  // cancelar oferta de empate pendente ao realizar um lance
  drawOffer=null; syncDrawButtons();
  // atualiza rel√≥gio de 50 lances
  if(capture || (p && p.t==='P')) halfmoveClock=0; else halfmoveClock++;
  // se pe√£o avan√ßou duas casas, habilita en passant para o oponente
  if(p && p.t==='P' && Math.abs(m.y - y)===2){
    const dir = p.c==='white' ? 1 : -1;
    const opp = (turn==='white' ? 'black' : 'white');
    enp = { x: x, y: y + dir, forColor: opp };
  }

  sel=null; opts=[];
  turn = turn==='white' ? 'black' : 'white';
  // registra a posi√ß√£o atual para repeti√ß√£o e checa empate imediato
  try{ recordPosition(); }catch(_){}
  try{
    const drawMsg = checkDrawConditions();
    if(drawMsg){ playSound('draw'); endGame(drawMsg); return; }
  }catch(_){}
  render(); updTurn(); updateStatus(); playSound(capture?'cap':'move');

  if(gameResult==='*'){ startClock(); switchClock(); }
  if(gameResult==='*' && ((mode==='ai' && turn==='black') || mode==='ava')){
    setTimeout(()=>{
      // IA: aceitar/recusar oferta de empate
      if(drawOffer){
        const s=clone(g);
        const sc=evalS(s);
        if(sc<=-50){ playSound('draw'); endGame('Empate aceito'); drawOffer=null; return; }
        else { drawOffer=null; updateStatus(); syncDrawButtons(); }
      }
      if(gameResult==='*' && !aiThinking){ runAI(); updateStatus(); }
    }, thinkDelay());
  }
  // Atualiza barra de avalia√ß√£o
  renderEvalBar();
}

function doMove(x,y,m){
  const p=g[y][x];
  const isPromo=needPromotion(p,m);
  const humanTurn = (mode==='pvp') || (mode==='ai' && turn==='white');
  if(isPromo && humanTurn){ pendingMove={x,y,m}; showPromo((piece)=>{ pendingMove.m.promote=piece; execMove(pendingMove.x,pendingMove.y,pendingMove.m); pendingMove=null; }); return; }
  if(isPromo && !humanTurn){ m.promote='Q'; }
  execMove(x,y,m);
}

function levelFor(color){ if(mode==='ava'){ const name=(color==='white'?aiWhiteName:aiBlackName); return aiProfiles[name]||'medio'; } return level; }
function ai(color){ 
  const lvl=levelFor(color); 
  // Nunca usar Tal ou Hard no thread principal
  if(lvl==='facil') return aiEasy(color); 
  return aiMed(color); 
}
async function runAI(){
  // Evitar reentr√¢ncia - n√£o iniciar nova an√°lise se j√° estiver pensando
  if(aiThinking) return;
  
  try{
    aiThinking = true;
    const beforeTurn=turn;
    const lvl = levelFor(beforeTurn);
    
    // Motor por lado (Stockfish como padr√£o)
    window.engineWhite = window.engineWhite || 'stockfish';
    window.engineBlack = window.engineBlack || 'stockfish';
    const engine = (beforeTurn === 'white') ? window.engineWhite : window.engineBlack;
    
    // Seleciona worker
    let worker = null;
    if (engine === 'stockfish') {
      try { worker = await (typeof ensureSfWorker==='function' ? ensureSfWorker() : new Worker('sf-worker.js')); } catch(_){ worker=null; }
    } else {
      worker = await ensureAIWorker();
    }
    
    if(worker){
      aiWorker = worker;
      let resolved=false;
      const onMsg=(ev)=>{
        resolved=true;
        try{ aiWorker.removeEventListener('message', onMsg); }catch(_){}
        if(turn!==beforeTurn){ aiThinking=false; return; }
        if(gameResult && gameResult!=='*'){ aiThinking=false; return; }
        const d=ev.data||{};
        
        // Falha do motor: quando Stockfish est√° selecionado, N√ÉO fazer fallback silencioso
        if (d.error) {
          console.warn('Motor falhou:', d.error, d.detail||'', d.wasm||'');
          lastAISrc = null;
          if(engine === 'stockfish'){
            try{ alert('Stockfish falhou ao inicializar: '+String(d.detail||d.error)); }catch(_){}
            aiThinking=false; updateStatus(); return;
          }
          try { (lvl==='tal' ? aiMed : aiEasy)(beforeTurn); } catch(_){}
          aiThinking=false; updateStatus(); return;
        }
        
        // Suporte UCI (Stockfish)
        if (d.uci) {
          try {
            const from = d.uci.substring(0,2), to = d.uci.substring(2,4);
            const promotion = d.uci.length>4 ? d.uci.substring(4,5).toUpperCase() : null;
            const fromX = from.charCodeAt(0) - 97, fromY = parseInt(from[1]) - 1;
            const toX = to.charCodeAt(0) - 97, toY = parseInt(to[1]) - 1;
            if (fromX>=0 && fromX<8 && fromY>=0 && fromY<8) {
              const piece = g[fromY][fromX];
              if (piece && piece.c === beforeTurn) {
                const legals = legalOn(g, fromX, fromY) || [];
                const matched = legals.find(m => m.x===toX && m.y===toY);
                if (matched) {
                  if (promotion) matched.promote = promotion;
                  // Marca a origem: 'book' quando vier do livro de aberturas
                  lastAISrc = (d && d.engine) ? d.engine : 'stockfish';
                  // Atualiza avalia√ß√£o enviada pelo Stockfish
                  if(d.eval){ window.evalLatest = d.eval; }
                  doMove(fromX, fromY, matched);
                  updateStatus();
                  aiThinking = false;
                  return;
                }
              }
            }
          } catch(_){}
        }
        
        // Mensagens do Tal
        if(d.src){ console.info('Tal origem:', d.src); }
        lastAISrc = d.src || engine || null;
        
        if(typeof d.x==='number' && typeof d.y==='number' && d.m){
          // Validar jogada enviada pelo worker contra o estado atual
          const inBounds = (d.x>=0 && d.x<8 && d.y>=0 && d.y<8);
          const piece = inBounds ? (g[d.y] && g[d.y][d.x]) : null;
          if(piece && piece.c===beforeTurn){
            try{
              const legals = legalOn(g, d.x, d.y) || [];
              // encontre o objeto de movimento interno (mm) correspondente
              const matched = legals.find(mm =>
                mm.x===d.m.x && mm.y===d.m.y &&
                (!!mm.castle === !!d.m.castle) && (!!mm.ep === !!d.m.ep)
              );
              if(matched){
                // propagar promo√ß√£o se o worker forneceu
                if(d.m && d.m.promote){ matched.promote = d.m.promote; }
                doMove(d.x, d.y, matched);
              } else { 
                // jogada inv√°lida: limpar origem e fallback
                lastAISrc = null;
                try{ aiEasy(beforeTurn); }catch(__){} 
              }
            }catch(_){ 
              lastAISrc = null; // limpa origem se erro
              try{ aiEasy(beforeTurn); }catch(__){} 
            }
          } else {
            lastAISrc = null; // limpa origem se pe√ßa inv√°lida
            try{ aiEasy(beforeTurn); }catch(_){ /* fallback silencioso */ }
          }
        } else {
          lastAISrc = null; // limpa origem se dados inv√°lidos
          try{ aiEasy(beforeTurn); }catch(_){}
        }
        updateStatus();
        aiThinking = false;
      };
      aiWorker.addEventListener('message', onMsg);
      try{
        const learn = loadTalLearn();
        // Semente de livro pessoal para KRRK (duas torres vs rei)
        function seedTalBook(book){
          try{
            const seeds={
              '4k3/8/8/8/8/8/8/R3K2R w KQ - 0 1': { 'e1e7': 8, 'h1h7': 8, 'a1a7': 8 },
              '4k3/8/8/8/8/4R3/8/4RK2 w - - 0 1': { 'f1f6': 8, 'e2e6': 8 },
              '4k3/8/8/8/8/8/4R3/4RK2 w - - 0 1': { 'e1e6': 8, 'f1f6': 8 }
            };
            for(const fen in seeds){ if(!book[fen]) book[fen]={}; const moves=seeds[fen]; for(const uci in moves){ book[fen][uci]=(book[fen][uci]||0)+moves[uci]; } }
          }catch(_){ /* silencioso */ }
        }
        seedTalBook(learn.book||(learn.book={})); saveTalLearn(learn);
        const fenNow = toFEN(g, beforeTurn);
        const personal = (learn && learn.book && learn.book[fenNow]) ? learn.book[fenNow] : null;
        
        // Tempo personalizado para Stockfish por lado
    const budget = (engine==='stockfish')
      ? Math.max(800, (beforeTurn === 'white' ? window.sfTimeMsWhite : window.sfTimeMsBlack))
      : Math.max(600, thinkDelay());
          
        const payload={ g: JSON.parse(JSON.stringify(g)), color: beforeTurn, level: lvl, enp: enp, budgetMs: budget, learnBook: personal, engine: engine, fen: fenNow, movetimeMs: (engine==='stockfish') ? budget : undefined };
        aiWorker.postMessage(payload);
      }catch(_){ 
        // Libera a trava em caso de erro
        aiThinking = false;
      }
      setTimeout(()=>{ 
        if(!resolved && turn===beforeTurn && (gameResult==='*')){ 
          try{
            const lvlTimeout = levelFor(beforeTurn);
            if(lvlTimeout==='tal') aiMed(beforeTurn); else aiEasy(beforeTurn);
          }catch(_){}
          aiThinking=false;
          updateStatus(); 
        } 
      }, Math.max(1200, thinkDelay()+600));
    } else {
      // Sem worker: nunca rodar Tal no thread principal (congela)
      try{ aiMed(beforeTurn); }catch(_){}
      setTimeout(()=>{ 
        aiThinking=false; 
        if(turn===beforeTurn) { try{ aiEasy(beforeTurn); }catch(_){ /* silencioso */ } } 
      }, 1200);
      updateStatus();
    }
  }catch(e){
    // Libera a trava em caso de erro
    aiThinking = false;
    try{ aiEasy(turn); }catch(_){}
  }
}
function thinkDelay(){
  try{
    const lvl = levelFor(turn);
    let base=(lvl==='facil')?200:(lvl==='medio')?600:(lvl==='dificil')?1200:1600;
    if(timeMode==='classica') base+=600; else if(timeMode==='rapida') base+=300; else if(timeMode==='blitz') base+=150; else if(timeMode==='bullet') base+=80;
    if(lvl==='tal'){ base += 300 * (typeof compDepthTal==='function' ? compDepthTal() : 4); }
    const jitter=Math.floor(Math.random()*200)-100;
    return Math.max(50, base + jitter);
  }catch(e){ return 250; }
}
function allLegal(s,color){let ms=[];for(let y=0;y<8;y++)for(let x=0;x<8;x++){const p=s[y][x];if(p&&p.c===color){const lm=legalOn(s,x,y);for(const m of lm)ms.push({x,y,m})}}return ms}
function legalOn(s,x,y){
  const p=s[y][x];
  let ms=pseudoOn(s,x,y);
  // adicionar roque aqui para evitar recurs√£o com isCheck dentro de pseudoOn
  if(p && p.t==='K'){
    const hasMoved=!!p.m; const rank=y;
    if(!hasMoved && x===4 && (rank===0||rank===7) && !isCheck(s,p.c)){
      // pequeno (rei para g, torre h->f)
      const rookK=s[rank][7];
      if(rookK && rookK.t==='R' && rookK.c===p.c && !rookK.m){
        if(!s[rank][5] && !s[rank][6] && !attacked(s,p.c,5,rank) && !attacked(s,p.c,6,rank)) ms.push({x:6,y:rank,castle:'K'});
      }
      // grande (rei para c, torre a->d)
      const rookQ=s[rank][0];
      if(rookQ && rookQ.t==='R' && rookQ.c===p.c && !rookQ.m){
        if(!s[rank][1] && !s[rank][2] && !s[rank][3] && !attacked(s,p.c,3,rank) && !attacked(s,p.c,2,rank)) ms.push({x:2,y:rank,castle:'Q'});
      }
    }
  }
  return ms.filter(m=>{const c=clone(s);apply(c,x,y,m);return !isCheck(c,p.c)})
}
function evalS(s){
  let score=0;
  const val = (window.pieceValues && typeof window.pieceValues==='object')
    ? window.pieceValues
    : { P:100, N:320, B:330, R:500, Q:900, K:0 };
  let mobB=0, mobW=0;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=s[y][x]; if(!p) continue;
    score += (p.c==='black' ? (val[p.t]||0) : -(val[p.t]||0));
    const mlen = pseudoOn(s,x,y).length;
    if(p.c==='black') mobB += mlen; else mobW += mlen;
  }
  return score + 0.1*(mobB - mobW);
}
function aiEasy(color){const ms=allLegal(g,color);if(ms.length===0)return;const r=ms[Math.floor(Math.random()*ms.length)];doMove(r.x,r.y,r.m)}
function aiMed(color){const ms=allLegal(g,color);if(ms.length===0)return;let best=ms[0],bs=-1e9;for(const mv of ms){const s=clone(g);apply(s,mv.x,mv.y,mv.m);let sc=evalS(s);sc = (color==='black')? sc : -sc; if(sc>bs){bs=sc;best=mv}}doMove(best.x,best.y,best.m)}
function aiHard(color){const depth=compDepth();const s=clone(g);const r=minimax(s,depth,-1e9,1e9,(color==='black'));if(r&&r.best)doMove(r.best.x,r.best.y,r.best.m)}
function compDepth(){let pcs=0;for(let y=0;y<8;y++)for(let x=0;x<8;x++)if(g[y][x])pcs++;if(pcs<=10)return 4;if(pcs<=18)return 3;return 2}
function minimax(s,d,a,b,max){const color=max?'black':'white';const ms=allLegal(s,color);if(d===0||ms.length===0){if(ms.length===0)return{score:max?-9999:9999};return{score:evalS(s)}}let best=null;if(max){let me=-1e9;for(const mv of order(ms)){const c=clone(s);apply(c,mv.x,mv.y,mv.m);const r=minimax(c,d-1,a,b,false);if(r.score>me){me=r.score;best=mv}a=Math.max(a,me);if(b<=a)break}return{score:me,best}}else{let mi=1e9;for(const mv of order(ms)){const c=clone(s);apply(c,mv.x,mv.y,mv.m);const r=minimax(c,d-1,a,b,true);if(r.score<mi){mi=r.score;best=mv}b=Math.min(b,mi);if(b<=a)break}return{score:mi,best}}}
function order(ms){return ms.slice().sort((a,b)=>((b.m.cap?1:0)-(a.m.cap?1:0)))}
// --- IA Tal (Mikhail Tal style): agressiva, profunda e t√°tica ---
function aiTal(color){
  const depth = compDepthTal();
  const s = clone(g);
  const r = minimaxTal(s, depth, -1e9, 1e9, (color==='black'));
  if(r && r.best) doMove(r.best.x, r.best.y, r.best.m);
}

function compDepthTal(){
  // Profundidade maior e din√¢mica conforme n√∫mero de pe√ßas
  let pcs=0; for(let y=0;y<8;y++) for(let x=0;x<8;x++) if(g[y][x]) pcs++;
  if(pcs<=10) return 6; // finais mais profundos
  if(pcs<=18) return 5;
  return 4;
}

function evalAgg(s){
  // Avalia√ß√£o agressiva: material + mobilidade refor√ßada + seguran√ßa do rei + controle de centro + avan√ßo de pe√µes
  const val = (window.pieceValues && typeof window.pieceValues==='object')
    ? window.pieceValues
    : { P:100, N:320, B:330, R:500, Q:900, K:0 };
  let score=0, mobB=0, mobW=0;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=s[y][x]; if(!p) continue;
    // material
    score += (p.c==='black'? (val[p.t]||0) : -(val[p.t]||0));
    // mobilidade bruta
    const mlen = pseudoOn(s,x,y).length;
    if(p.c==='black') mobB += mlen; else mobW += mlen;
    // centro: bonus por proximidade ao centro
    const cx = Math.abs(3.5 - x), cy = Math.abs(3.5 - y); const centerBonus = Math.max(0, 3 - (cx+cy));
    score += (p.c==='black'? +centerBonus*2 : -centerBonus*2);
    // avan√ßo de pe√µes
    if(p.t==='P'){
      if(p.c==='black') score += (6 - y) * 5; else score -= (y - 1) * 5;
    }
    // penaliza√ß√£o por pe√ßas penduradas (atacadas e mal defendidas)
    const opp = p.c==='black' ? 'white' : 'black';
    let def=0, att=0, minAtt=Infinity;
    for(let yy=0; yy<8; yy++) for(let xx=0; xx<8; xx++){
      const q=s[yy][xx]; if(!q) continue;
      const ps=pseudoOn(s,xx,yy);
      for(const m of ps){
        if(m.x===x && m.y===y){
          if(q.c===opp){ att++; const v=val[q.t]||0; if(v<minAtt) minAtt=v; }
          else def++;
          break;
        }
      }
    }
    if(att>0 && def===0){
      const penalty=(val[p.t]||0)*0.6;
      score += (p.c==='black' ? -penalty : +penalty);
    } else if(att>0 && def>0){
      const myVal=val[p.t]||0;
      if(minAtt <= myVal){
        const penalty = (myVal - minAtt)*0.4 + 40;
        score += (p.c==='black' ? -penalty : +penalty);
      }
    }
  }
  // seguran√ßa do rei: b√¥nus por colocar o rei advers√°rio em xeque
  const inCheckWhite = isCheck(s,'white');
  const inCheckBlack = isCheck(s,'black');
  if(inCheckWhite) score += 50;
  if(inCheckBlack) score -= 50;
  // b√¥nus de rede de mate: reduzir casas seguras do rei advers√°rio
  function kingPos(side){
    for(let y=0;y<8;y++) for(let x=0;x<8;x++){ const p=s[y][x]; if(p&&p.c===side&&p.t==='K') return {x,y}; }
    return null;
  }
  const wK=kingPos('white');
  const bK=kingPos('black');
  function safeSquaresAround(kx,ky, defenderSide){
    let safe=0;
    const dirs=[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=kx+dx, ny=ky+dy;
      if(nx<0||nx>7||ny<0||ny>7) continue;
      const occ=s[ny][nx];
      if(occ && occ.c===defenderSide) continue; // casa ocupada pelo pr√≥prio lado do rei
      // casa segura se N√ÉO for atacada pelo lado oposto
      if(!attacked(s, defenderSide, nx, ny)) safe++;
    }
    return safe;
  }
  if(wK){ const safeW = safeSquaresAround(wK.x, wK.y, 'white'); score += (8 - safeW) * 6; let pcs=0; for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++) if(s[yy][xx]) pcs++; if(window.talDebug && pcs<=10) logTal('Rede de mate (white king safe squares)', { safeW, pcs }); }
  if(bK){ const safeB = safeSquaresAround(bK.x, bK.y, 'black'); score -= (8 - safeB) * 6; let pcs=0; for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++) if(s[yy][xx]) pcs++; if(window.talDebug && pcs<=10) logTal('Rede de mate (black king safe squares)', { safeB, pcs }); }
  // mobilidade refor√ßada
  score += 0.2 * (mobB - mobW);
  return score;
}

function minimaxTal(s, d, a, b, max, ply){
  if(typeof ply==='undefined') ply=0;
  const color = max ? 'black' : 'white';
  const ms = allLegal(s, color);
  // n√≥ terminal ou profundidade 0: quiescence search para evitar efeito horizonte
  if(d===0 || ms.length===0){
    if(ms.length===0){
      // distingue xeque-mate de afogamento (stalemate)
      const losing = isCheck(s, color);
      const score = losing ? (max ? -99999 : 99999) : 0;
      return { score };
    }
    const qs = qSearch(s, a, b, max);
    return { score: qs };
  }
  let best=null;
  if(max){
    let me=-1e9;
    for(const mv of orderTal(ms, s, color, ply)){
      const c=clone(s);
      apply(c, mv.x, mv.y, mv.m);
      // extens√£o por cheque
      const opp = 'white';
      const ext = isCheck(c, opp) ? 1 : 0;
      // bloquear sacrif√≠cios com pe√ßas pesadas que n√£o d√£o cheque
      const mover = s[mv.y][mv.x];
      const isCap = !!mv.m.cap;
      const isChk = ext>0;
      function isSacrificeMoveLocal(){
        if(!mover) return false;
        if(!(mover.t==='Q'||mover.t==='R'||mover.t==='B')) return false;
        const val={P:100,N:320,B:330,R:510,Q:900,K:10000};
        const myVal=val[mover.t]||0;
        const victim = s[mv.m.y][mv.m.x];
        const victimVal = victim ? (val[victim.t]||0) : 0;
        const destAttacked = attacked(c, mover.c, mv.m.x, mv.m.y);
        const destDefended = attacked(c, opp, mv.m.x, mv.m.y);
        return destAttacked && !isChk && (victimVal < myVal) && !destDefended;
      }
      if(isSacrificeMoveLocal()){ logTal('Sacrif√≠cio bloqueado', { piece: mover.t, from: sq(mv.x,mv.y), to: sq(mv.m.x,mv.m.y), check: isChk }); continue; }
      const pen = checkUncoveredPenalty(s, mv);
      const r=minimaxTal(c, d-1+ext, a, b, false, ply+1);
      if(pen>0){ r.score -= pen; }
      try{
        const ur0 = scholarThreatUrgency(s, 'black');
        const ur1 = scholarThreatUrgency(c, 'black');
        if(ur0>0 && ur1>=ur0){ r.score -= Math.min(120, 40*ur1); }
      }catch(_){/* silencioso */}
      if(r.score>me){me=r.score;best=mv}
      a=Math.max(a, me);
      if(b<=a) break;
    }
    return { score: me, best };
  } else {
    let mi=1e9;
    for(const mv of orderTal(ms, s, color, ply)){
      const c=clone(s);
      apply(c, mv.x, mv.y, mv.m);
      const opp = 'black';
      const ext = isCheck(c, opp) ? 1 : 0;
      const mover = s[mv.y][mv.x];
      function isSacrificeMoveLocal(){
        if(!mover) return false;
        if(!(mover.t==='Q'||mover.t==='R'||mover.t==='B')) return false;
        const val={P:100,N:320,B:330,R:510,Q:900,K:10000};
        const myVal=val[mover.t]||0;
        const victim = s[mv.m.y][mv.m.x];
        const victimVal = victim ? (val[victim.t]||0) : 0;
        const destAttacked = attacked(c, mover.c, mv.m.x, mv.m.y);
        const destDefended = attacked(c, opp, mv.m.x, mv.m.y);
        const isChk = ext>0;
        return destAttacked && !isChk && (victimVal < myVal) && !destDefended;
      }
      if(isSacrificeMoveLocal()){ logTal('Sacrif√≠cio bloqueado', { piece: mover.t, from: sq(mv.x,mv.y), to: sq(mv.m.x,mv.m.y), check: (ext>0) }); continue; }
      const pen = checkUncoveredPenalty(s, mv);
      const r=minimaxTal(c, d-1+ext, a, b, true, ply+1);
      if(pen>0){ r.score += pen; }
      try{
        const ur0 = scholarThreatUrgency(s, 'white');
        const ur1 = scholarThreatUrgency(c, 'white');
        if(ur0>0 && ur1>=ur0){ r.score += Math.min(120, 40*ur1); }
      }catch(_){/* silencioso */}
      try{
        const ur0 = scholarThreatUrgency(s, 'white');
        const ur1 = scholarThreatUrgency(c, 'white');
        if(ur0>0 && ur1>=ur0){ r.score += Math.min(120, 40*ur1); }
      }catch(_){/* silencioso */}
      if(r.score<mi){mi=r.score;best=mv}
      b=Math.min(b, mi);
      if(b<=a) break;
    }
    return { score: mi, best };
  }
}

function qSearch(s, a, b, max){
  // Stand pat
  let stand = evalAgg(s);
  if(max){ if(stand >= b) return stand; if(stand > a) a = stand; }
  else { if(stand <= a) return stand; if(stand < b) b = stand; }
  const color = max ? 'black' : 'white';
  const caps = allLegal(s, color).filter(mv => !!mv.m.cap);
  if(caps.length===0) return stand;
  for(const mv of orderTal(caps, s, color)){
    const c=clone(s); apply(c, mv.x, mv.y, mv.m);
    const score = qSearch(c, a, b, !max);
    if(max){
      if(score > a) a = score;
      if(a >= b) return a;
    } else {
      if(score < b) b = score;
      if(b <= a) return b;
    }
  }
  return max ? a : b;
}


function givesCheckOn(s, mv){
  const c=clone(s); apply(c, mv.x, mv.y, mv.m);
  const mover = s[mv.y][mv.x];
  if(!mover) return 0;
  const opp = mover.c==='black' ? 'white' : 'black';
  return isCheck(c, opp) ? 1 : 0;
}

// --- IA Tal (Mikhail Tal style): agressiva, profunda e t√°tica ---
function aiTal(color){
  const depth = compDepthTal();
  const s = clone(g);
  const r = minimaxTal(s, depth, -1e9, 1e9, (color==='black'));
  if(r && r.best) doMove(r.best.x, r.best.y, r.best.m);
}

function compDepthTal(){
  // Profundidade maior e din√¢mica conforme n√∫mero de pe√ßas
  let pcs=0; for(let y=0;y<8;y++) for(let x=0;x<8;x++) if(g[y][x]) pcs++;
  if(pcs<=10) return 6; // finais mais profundos
  if(pcs<=18) return 5;
  return 4;
}

function evalAgg(s){
  // Avalia√ß√£o agressiva: material + mobilidade refor√ßada + seguran√ßa do rei + controle de centro + avan√ßo de pe√µes
  const val={P:100,N:320,B:330,R:510,Q:900,K:0};
  let score=0, mobB=0, mobW=0;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=s[y][x]; if(!p) continue;
    // material
    score += (p.c==='black'? val[p.t] : -val[p.t]);
    // mobilidade bruta
    const mlen = pseudoOn(s,x,y).length;
    if(p.c==='black') mobB += mlen; else mobW += mlen;
    // centro: bonus por proximidade ao centro
    const cx = Math.abs(3.5 - x), cy = Math.abs(3.5 - y); const centerBonus = Math.max(0, 3 - (cx+cy));
    score += (p.c==='black'? +centerBonus*2 : -centerBonus*2);
    // avan√ßo de pe√µes
    if(p.t==='P'){
      if(p.c==='black') score += (6 - y) * 5; else score -= (y - 1) * 5;
    }
  }
  // seguran√ßa do rei: b√¥nus por colocar o rei advers√°rio em xeque
  const inCheckWhite = isCheck(s,'white');
  const inCheckBlack = isCheck(s,'black');
  if(inCheckWhite) score += 50;
  if(inCheckBlack) score -= 50;
  // b√¥nus de rede de mate: reduzir casas seguras do rei advers√°rio
  function kingPos(side){
    for(let y=0;y<8;y++) for(let x=0;x<8;x++){ const p=s[y][x]; if(p&&p.c===side&&p.t==='K') return {x,y}; }
    return null;
  }
  const wK=kingPos('white');
  const bK=kingPos('black');
  function safeSquaresAround(kx,ky, defenderSide){
    let safe=0;
    const dirs=[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=kx+dx, ny=ky+dy;
      if(nx<0||nx>7||ny<0||ny>7) continue;
      const occ=s[ny][nx];
      if(occ && occ.c===defenderSide) continue;
      if(!attacked(s, defenderSide, nx, ny)) safe++;
    }
    return safe;
  }
  if(wK){ const safeW = safeSquaresAround(wK.x, wK.y, 'white'); score += (8 - safeW) * 6; let pcs=0; for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++) if(s[yy][xx]) pcs++; if(window.talDebug && pcs<=10) logTal('Rede de mate (white king safe squares)', { safeW, pcs }); }
  if(bK){ const safeB = safeSquaresAround(bK.x, bK.y, 'black'); score -= (8 - safeB) * 6; let pcs=0; for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++) if(s[yy][xx]) pcs++; if(window.talDebug && pcs<=10) logTal('Rede de mate (black king safe squares)', { safeB, pcs }); }
  // mobilidade refor√ßada
  score += 0.2 * (mobB - mobW);
  return score;
}

// SEE simplificado e penaliza√ß√£o de cheque sem cobertura
// Heur√≠sticas globais: hist√≥rico e killers
window.talHistory = window.talHistory || {};
window.talKillers = window.talKillers || {};
function uciOfMove(mv){
  const from = sq(mv.x, mv.y);
  const to = sq(mv.m.x, mv.m.y);
  return mv.m.promote ? (from+to+mv.m.promote.toLowerCase()) : (from+to);
}
function countAttackDefend(board, x, y, myColor){
  const opp = myColor==='black' ? 'white' : 'black';
  let att=0, def=0, minAtt=Infinity;
  for(let yy=0; yy<8; yy++) for(let xx=0; xx<8; xx++){
    const p=board[yy][xx]; if(!p) continue;
    const ps=pseudoOn(board,xx,yy);
    for(const m of ps){
      if(m.x===x && m.y===y){
        if(p.c===opp){ att++; const v=(window.pieceValues? window.pieceValues[p.t] : ({P:100,N:320,B:330,R:510,Q:900,K:10000})[p.t])||0; if(v<minAtt) minAtt=v; }
        else def++;
        break;
      }
    }
  }
  return {att, def, minAtt};
}

function simpleSEE(board, mv){
  const val = window.pieceValues ? { ...window.pieceValues, K:10000 } : {P:100,N:320,B:330,R:510,Q:900,K:10000};
  const mover = board[mv.y][mv.x]; if(!mover) return 0;
  const victim = board[mv.m.y][mv.m.x];
  const myVal = val[mover.t]||0;
  const victimVal = victim ? (val[victim.t]||0) : 0;
  const {att, def, minAtt} = countAttackDefend(board, mv.m.x, mv.m.y, mover.c);
  if(att===0) return victimVal; // captura segura
  if(def===0) return victimVal - myVal; // pendurada
  if(minAtt <= myVal && att > def) return victimVal - myVal; // prov√°vel troca desfavor√°vel
  return victimVal; // neutro ou leve ganho
}

function checkUncoveredPenalty(board, mv){
  const after = clone(board); apply(after, mv.x, mv.y, mv.m);
  const mover = board[mv.y][mv.x]; if(!mover) return 0;
  const opp = mover.c==='black' ? 'white' : 'black';
  const isChk = isCheck(after, opp);
  if(!isChk) return 0;
  const val = window.pieceValues ? { ...window.pieceValues, K:10000 } : {P:100,N:320,B:330,R:510,Q:900,K:10000};
  const myVal = val[mover.t]||0;
  const destAttacked = attacked(after, mover.c, mv.m.x, mv.m.y);
  const destDefended = attacked(after, opp, mv.m.x, mv.m.y);
  if(destAttacked && !destDefended) return Math.min(myVal*0.8, 150);
  if(destAttacked && destDefended){
    const see = simpleSEE(board, mv);
    if(see < 0) return Math.min(-see, Math.max(60, myVal*0.6));
  }
  return 0;
}

// Defesa contra padr√µes de mate r√°pido (f7/f2)
function fSquare(color){ return color==='black' ? {x:5,y:6} : {x:5,y:1}; }
function scholarThreatUrgency(board, color){
  const {x,y} = fSquare(color);
  const cnt = countAttackDefend(board, x, y, color);
  let urgency = Math.max(0, cnt.att - cnt.def);
  // ataque combinado de bispo e dama ao f7/f2 aumenta urg√™ncia
  const opp = color==='black' ? 'white' : 'black';
  let bishopAttack=false, queenAttack=false;
  for(let yy=0; yy<8; yy++) for(let xx=0; xx<8; xx++){
    const p=board[yy][xx]; if(!p || p.c!==opp) continue;
    const ps=pseudoOn(board,xx,yy);
    for(const m of ps){ if(m.x===x && m.y===y){ if(p.t==='B') bishopAttack=true; if(p.t==='Q') queenAttack=true; break; } }
  }
  if(bishopAttack && queenAttack) urgency += 1;
  return urgency;
}
function defenseImprovement(board, mv, color){
  const u0 = scholarThreatUrgency(board, color);
  const c = clone(board); apply(c, mv.x, mv.y, mv.m);
  const u1 = scholarThreatUrgency(c, color);
  return u0 - u1;
}

function minimaxTal(s, d, a, b, max, ply){
  if(typeof ply==='undefined') ply=0;
  const color = max ? 'black' : 'white';
  const ms = allLegal(s, color);
  // n√≥ terminal ou profundidade 0: quiescence search para evitar efeito horizonte
  if(d===0 || ms.length===0){
    if(ms.length===0){
      // distingue xeque-mate de afogamento (stalemate)
      const losing = isCheck(s, color);
      const score = losing ? (max ? -99999 : 99999) : 0;
      return { score };
    }
    const qs = qSearch(s, a, b, max);
    return { score: qs };
  }
  let best=null;
  if(max){
    let me=-1e9;
    for(const mv of orderTal(ms, s, color, ply)){
      const c=clone(s);
      apply(c, mv.x, mv.y, mv.m);
      // extens√£o por cheque
      const opp = 'white';
      const ext = isCheck(c, opp) ? 1 : 0;
      // bloquear sacrif√≠cios com pe√ßas pesadas que n√£o d√£o cheque
      const mover = s[mv.y][mv.x];
      const isChk = ext>0;
      function isSacrificeMoveLocal(){
        if(!mover) return false;
        if(!(mover.t==='Q'||mover.t==='R'||mover.t==='B')) return false;
        const val={P:100,N:320,B:330,R:510,Q:900,K:10000};
        const myVal=val[mover.t]||0;
        const victim = s[mv.m.y][mv.m.x];
        const victimVal = victim ? (val[victim.t]||0) : 0;
        const destAttacked = attacked(c, mover.c, mv.m.x, mv.m.y);
        const destDefended = attacked(c, opp, mv.m.x, mv.m.y);
        return destAttacked && !isChk && (victimVal < myVal) && !destDefended;
      }
      if(isSacrificeMoveLocal()){ logTal('Sacrif√≠cio bloqueado', { piece: mover?.t, from: sq(mv.x,mv.y), to: sq(mv.m.x,mv.m.y), check: isChk }); continue; }
      // Penalizar cheque sem cobertura
      const pen = checkUncoveredPenalty(s, mv);
      const r=minimaxTal(c, d-1+ext, a, b, false, ply+1);
      if(pen>0){ r.score -= pen; }
      if(r.score>me){me=r.score;best=mv}
      a=Math.max(a, me);
      if(b<=a){
        const u = uciOfMove(mv);
        const ks = window.talKillers[ply] || (window.talKillers[ply]=[]);
        if(!ks.includes(u)){ window.talKillers[ply] = [u].concat(ks).slice(0,2); }
        window.talHistory[u] = (window.talHistory[u]||0) + (d+1);
        break;
      }
    }
    return { score: me, best };
  } else {
    let mi=1e9;
    for(const mv of orderTal(ms, s, color, ply)){
      const c=clone(s);
      apply(c, mv.x, mv.y, mv.m);
      const opp = 'black';
      const ext = isCheck(c, opp) ? 1 : 0;
      const mover = s[mv.y][mv.x];
      function isSacrificeMoveLocal(){
        if(!mover) return false;
        if(!(mover.t==='Q'||mover.t==='R'||mover.t==='B')) return false;
        const val={P:100,N:320,B:330,R:510,Q:900,K:10000};
        const myVal=val[mover.t]||0;
        const victim = s[mv.m.y][mv.m.x];
        const victimVal = victim ? (val[victim.t]||0) : 0;
        const destAttacked = attacked(c, mover.c, mv.m.x, mv.m.y);
        const destDefended = attacked(c, opp, mv.m.x, mv.m.y);
        const isChk = ext>0;
        return destAttacked && !isChk && (victimVal < myVal) && !destDefended;
      }
      if(isSacrificeMoveLocal()){ logTal('Sacrif√≠cio bloqueado', { piece: mover?.t, from: sq(mv.x,mv.y), to: sq(mv.m.x,mv.m.y), check: (ext>0) }); continue; }
      // Penalizar cheque sem cobertura
      const pen = checkUncoveredPenalty(s, mv);
      const r=minimaxTal(c, d-1+ext, a, b, true, ply+1);
      if(pen>0){ r.score += pen; }
      if(r.score<mi){mi=r.score;best=mv}
      b=Math.min(b, mi);
      if(b<=a){
        const u = uciOfMove(mv);
        const ks = window.talKillers[ply] || (window.talKillers[ply]=[]);
        if(!ks.includes(u)){ window.talKillers[ply] = [u].concat(ks).slice(0,2); }
        window.talHistory[u] = (window.talHistory[u]||0) + (d+1);
        break;
      }
    }
    return { score: mi, best };
  }
}

function qSearch(s, a, b, max){
  // Stand pat
  let stand = evalAgg(s);
  if(max){ if(stand >= b) return stand; if(stand > a) a = stand; }
  else { if(stand <= a) return stand; if(stand < b) b = stand; }
  const color = max ? 'black' : 'white';
  const caps = allLegal(s, color).filter(mv => !!mv.m.cap);
  if(caps.length===0) return stand;
  for(const mv of orderTal(caps, s, color)){
    const c=clone(s); apply(c, mv.x, mv.y, mv.m);
    const score = qSearch(c, a, b, !max);
    if(max){
      if(score > a) a = score;
      if(a >= b) return a;
    } else {
      if(score < b) b = score;
      if(b <= a) return b;
    }
  }
  return max ? a : b;
}

function orderTal(ms, s, color, ply){
  // Priorizar cheques, depois capturas por MVV-LVA, depois demais
  const valMap = window.pieceValues ? { ...window.pieceValues, K:10000 } : {P:100,N:320,B:330,R:510,Q:900,K:10000};
  const killers = window.talKillers[ply||0] || [];
  const ur = scholarThreatUrgency(s, color);
  function mvv(mv){
    const victim = s[mv.m.y][mv.m.x]; // no estado atual
    const attacker = s[mv.y][mv.x];
    const vv = victim ? valMap[victim.t] : 0;
    const av = attacker ? valMap[attacker.t] : 0;
    return vv - av;
  }
  function isMoveUnsafe(mv){
    const c = clone(s); apply(c, mv.x, mv.y, mv.m);
    const mover = s[mv.y][mv.x]; if(!mover) return false;
    const my = mover.c;
    const opp = my==='black' ? 'white' : 'black';
    let att=0, def=0, minAtt=Infinity;
    for(let yy=0; yy<8; yy++) for(let xx=0; xx<8; xx++){
      const p=c[yy][xx]; if(!p) continue;
      const ps=pseudoOn(c,xx,yy);
      for(const m of ps){
        if(m.x===mv.m.x && m.y===mv.m.y){
          if(p.c===opp){ att++; const v=valMap[p.t]||0; if(v<minAtt) minAtt=v; }
          else def++;
          break;
        }
      }
    }
    if(att===0) return false;
    if(def===0) return true;
    const myVal = valMap[mover.t]||0;
    return minAtt <= myVal;
  }
  return ms.slice().sort((a,b)=>{
    // Killer moves primeiro
    const ua = uciOfMove(a); const ub = uciOfMove(b);
    const aK = killers.includes(ua)?1:0; const bK = killers.includes(ub)?1:0;
    if(aK!==bK) return bK - aK;
    if(ur>0){
      const impA = defenseImprovement(s, a, color);
      const impB = defenseImprovement(s, b, color);
      if(impA!==impB) return impB - impA;
    }
    // Seguran√ßa primeiro: lances inseguros depois
    const aUnsafe = isMoveUnsafe(a)?1:0;
    const bUnsafe = isMoveUnsafe(b)?1:0;
    if(aUnsafe!==bUnsafe) return aUnsafe - bUnsafe;
    const aCheck = givesCheckOn(s, a);
    const bCheck = givesCheckOn(s, b);
    if(aCheck!==bCheck) return bCheck - aCheck; // true(1) primeiro
    const ac = a.m.cap ? 1 : 0;
    const bc = b.m.cap ? 1 : 0;
    if(ac!==bc) return bc - ac; // capturas primeiro
    // Evitar ‚Äúdan√ßa‚Äù de rei: lances de rei sem cheque nem captura por √∫ltimo
    const aIsKing = !!(s[a.y][a.x]) && s[a.y][a.x].t==='K';
    const bIsKing = !!(s[b.y][b.x]) && s[b.y][b.x].t==='K';
    const aPassiveKing = aIsKing && !a.m.cap && !aCheck ? 1 : 0;
    const bPassiveKing = bIsKing && !b.m.cap && !bCheck ? 1 : 0;
    if(aPassiveKing!==bPassiveKing) return aPassiveKing - bPassiveKing;
    if(ac && bc){ // MVV-LVA
      const diff = mvv(b) - mvv(a);
      if(diff!==0) return diff;
    }
    // fallback: heur√≠stica de mobilidade futura simples
    const cA=clone(s); apply(cA,a.x,a.y,a.m);
    const cB=clone(s); apply(cB,b.x,b.y,b.m);
    const mobA = allLegal(cA, color).length;
    const mobB = allLegal(cB, color).length;
    if(mobB !== mobA) return mobB - mobA;
    // hist√≥rico como √∫ltimo desempate
    const ha = window.talHistory[ua]||0; const hb = window.talHistory[ub]||0;
    return hb - ha;
  });
}

function givesCheckOn(s, mv){
  const c=clone(s); apply(c, mv.x, mv.y, mv.m);
  const mover = s[mv.y][mv.x];
  if(!mover) return 0;
  const opp = mover.c==='black' ? 'white' : 'black';
  return isCheck(c, opp) ? 1 : 0;
}
// --- Fun√ß√µes de empate ---
function endGame(msg){
  try{ stopClock(); }catch(_){}
  const el=document.getElementById('status'); if(el) el.textContent=msg;
  gameResult = resultFromMsg(msg);
  // Atualiza livro pessoal do Tal com base no resultado
  try{
    const learn = loadTalLearn(); const book = learn.book || (learn.book={});
    const deltaWhite = (gameResult==='1-0') ? +2 : (gameResult==='0-1') ? -2 : +1;
    const deltaBlack = (gameResult==='0-1') ? +2 : (gameResult==='1-0') ? -2 : +1;
    // Usa todo o log (abertura e finais) para aprendizado pessoal
    for(let i=0;i<talMoveLog.length;i++){
      const {fen, uci, color} = talMoveLog[i]; if(!fen||!uci) continue;
      const delta = color==='white' ? deltaWhite : deltaBlack;
      book[fen] = book[fen] || {};
      book[fen][uci] = (book[fen][uci]||0) + delta;
      if(book[fen][uci] > 100) book[fen][uci]=100;
      if(book[fen][uci] < -20) book[fen][uci]=-20;
    }
    saveTalLearn(learn);
    talMoveLog=[];
  }catch(_){ /* silencioso */ }
  if(mode==='ava'){
    const w=aiWhiteName, b=aiBlackName;
    if(!aiScores[w]) aiScores[w]={wins:0,draws:0};
    if(!aiScores[b]) aiScores[b]={wins:0,draws:0};
    if(gameResult==='1-0'){ aiScores[w].wins++; }
    else if(gameResult==='0-1'){ aiScores[b].wins++; }
    else if(gameResult==='1/2-1/2'){ aiScores[w].draws++; aiScores[b].draws++; }
    saveScores(); renderScore();
  }
  if(bd) bd.querySelectorAll('.sq').forEach(s=> s.onclick=null);
}
function getCastleRights(s){
  const wK = s[0][4] && s[0][4].t==='K' && s[0][4].c==='white' && !s[0][4].m;
  const wRk = s[0][7] && s[0][7].t==='R' && s[0][7].c==='white' && !s[0][7].m;
  const wRq = s[0][0] && s[0][0].t==='R' && s[0][0].c==='white' && !s[0][0].m;
  const bK = s[7][4] && s[7][4].t==='K' && s[7][4].c==='black' && !s[7][4].m;
  const bRk = s[7][7] && s[7][7].t==='R' && s[7][7].c==='black' && !s[7][7].m;
  const bRq = s[7][0] && s[7][0].t==='R' && s[7][0].c==='black' && !s[7][0].m;
  let rights=''; if(wK&&wRk) rights+='K'; if(wK&&wRq) rights+='Q'; if(bK&&bRk) rights+='k'; if(bK&&bRq) rights+='q'; return rights||'-';
}
function getPositionKey(s,side,enp){
  let b='';
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=s[y][x]; b+= p ? (p.c[0]+p.t) : '.';
  }
  const ep = enp ? (enp.x+','+enp.y+','+enp.forColor) : '-';
  const rights = getCastleRights(s);
  return b+'|'+side+'|'+rights+'|'+ep;
}
function recordPosition(){ const key=getPositionKey(g,turn,enp); posCounts[key]=(posCounts[key]||0)+1; }
function insufficientMaterial(s){
  let w={p:0,n:0,b:0,r:0,q:0}, b={p:0,n:0,b:0,r:0,q:0};
  const wbColors=[], bbColors=[];
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=s[y][x]; if(!p) continue;
    if(p.c==='white'){
      if(p.t==='P') w.p++; else if(p.t==='N') w.n++; else if(p.t==='B'){ w.b++; wbColors.push((x+y)%2); } else if(p.t==='R') w.r++; else if(p.t==='Q') w.q++;
    } else {
      if(p.t==='P') b.p++; else if(p.t==='N') b.n++; else if(p.t==='B'){ b.b++; bbColors.push((x+y)%2); } else if(p.t==='R') b.r++; else if(p.t==='Q') b.q++;
    }
  }
  // qualquer pe√£o, torre ou dama presentes -> n√£o √© material insuficiente
  if(w.q+w.r+w.p>0 || b.q+b.r+b.p>0) return false;
  const wMin = w.b + w.n; const bMin = b.b + b.n;
  if(wMin===0 && bMin===0) return true;           // K vs K
  if(wMin<=1 && bMin===0) return true;            // K+minor vs K
  if(bMin<=1 && wMin===0) return true;            // K vs K+minor
  if(w.b===1 && b.b===1 && w.n===0 && b.n===0){   // K+B vs K+B (mesma cor)
    const wColor = wbColors[0]; const bColor = bbColors[0];
    if(typeof wColor!=='undefined' && typeof bColor!=='undefined' && wColor===bColor) return true;
  }
  if(w.n===1 && b.n===1 && w.b===0 && b.b===0) return true; // K+N vs K+N
  return false;
}
function checkDrawConditions(){
  if(halfmoveClock>=100) return 'Empate (regra dos 50 lances)';
  const key=getPositionKey(g,turn,enp); if(posCounts[key]>=3) return 'Empate por tripla repeti√ß√£o';
  if(insufficientMaterial(g)) return 'Empate por material insuficiente';
  return null;
}

// --- Nota√ß√£o SAN e PGN ---
function toSAN(s0,x,y,m){
  const p=s0[y][x]; if(!p) return '';
  // roque
  if(m.castle){
    let san = (m.castle==='K') ? 'O-O' : 'O-O-O';
    const c=clone(s0); apply(c,x,y,m);
    const opp = p.c==='white' ? 'black' : 'white';
    const inChk = isCheck(c, opp);
    const oppMoves = allLegal(c, opp);
    if(inChk && oppMoves.length===0) san += '#'; else if(inChk) san += '+';
    return san;
  }
  const piece = p.t==='P' ? '' : p.t;
  const fromFile = 'abcdefgh'[x];
  const dest = 'abcdefgh'[m.x] + (m.y+1);
  const capture = !!m.cap;
  let san='';
  if(piece){
    // desambigua√ß√£o m√≠nima
    let candidates=[];
    for(let yy=0;yy<8;yy++) for(let xx=0;xx<8;xx++){
      if(xx===x && yy===y) continue;
      const q=s0[yy][xx]; if(!q || q.c!==p.c || q.t!==p.t) continue;
      const lm = legalOn(s0, xx, yy);
      if(lm.some(mm=>mm.x===m.x && mm.y===m.y)) candidates.push({xx,yy});
    }
    let dis='';
    if(candidates.length>0){
      const sameFile = candidates.some(c=>c.xx===x);
      const sameRank = candidates.some(c=>c.yy===y);
      if(sameFile && !sameRank) dis = (y+1);
      else if(sameRank && !sameFile) dis = fromFile;
      else dis = fromFile + (y+1);
    }
    san = piece + (dis?dis:'') + (capture?'x':'') + dest;
  }else{
    san = capture ? (fromFile + 'x' + dest) : dest;
  }
  if(p.t==='P' && m.promote) san += '=' + m.promote;
  if(m.ep) san += ' e.p.';
  const c=clone(s0); apply(c,x,y,m);
  const opp = p.c==='white' ? 'black' : 'white';
  const inChk = isCheck(c, opp);
  const oppMoves = allLegal(c, opp);
  if(inChk && oppMoves.length===0) san += '#'; else if(inChk) san += '+';
  return san;
}

function renderMoves(){
  // criar painel se n√£o existir
  let panel=document.getElementById('movesPanel');
  if(!panel){
    panel=document.createElement('div'); panel.id='movesPanel';
    panel.style.maxWidth='min(92vw,520px)'; panel.style.margin='10px auto'; panel.style.background='rgba(255,255,255,.06)';
    panel.style.border='1px solid rgba(229,231,235,.25)'; panel.style.borderRadius='10px'; panel.style.padding='8px';
    const title=document.createElement('div'); title.textContent='Lances'; title.style.fontWeight='600'; title.style.marginBottom='6px'; panel.appendChild(title);
    const list=document.createElement('div'); list.id='movesList'; list.style.fontSize='14px'; panel.appendChild(list);
    const boardEl=document.getElementById('board'); if(boardEl && boardEl.parentNode){ boardEl.parentNode.insertBefore(panel, boardEl.nextSibling); }
  }
  const list=document.getElementById('movesList') || (function(){ const l=document.createElement('div'); l.id='movesList'; panel.appendChild(l); return l; })();
  function srcLabel(s){
    if(!s) return '';
    if(s==='book') return ' (book)';
    if(s==='tablebase') return ' (tb)';
    if(s==='stockfish') return ' (SF)';
    if(s==='tal') return ' (Tal)';
    return ' (search)';
  }
  const parts=[];
  for(const mv of moveHistory){
    const w = mv.w ? (mv.w + srcLabel(mv.wsrc)) : '';
    const b = mv.b ? (' ' + mv.b + srcLabel(mv.bsrc)) : '';
    parts.push(mv.num + '. ' + w + b);
  }
  list.textContent = parts.join(' ');
  // bot√£o Exportar PGN
  const uiEl=document.getElementById('ui');
  if(uiEl && !document.getElementById('exportPGN')){
    const btn=document.createElement('button'); btn.id='exportPGN'; btn.textContent='Exportar PGN';
    btn.onclick=()=>{
      const pgn=buildPGN();
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(pgn).then(()=>{ alert('PGN copiado para a √°rea de transfer√™ncia'); }).catch(()=>{ prompt('PGN', pgn); });
      }else{ prompt('PGN', pgn); }
    };
    uiEl.appendChild(btn);
  }
}

function buildPGN(){
  function pad(n){return String(n).padStart(2,'0');}
  function today(){ const d=new Date(); return d.getFullYear()+'.'+pad(d.getMonth()+1)+'.'+pad(d.getDate()); }
  const headers=[
    '[Event "Casual Game"]',
    '[Site "Local"]',
    '[Date "'+today()+'"]',
    '[Round "1"]',
    '[White "Brancas"]',
    '[Black "Pretas"]',
    '[Result "'+(gameResult||'*')+'"]'
  ].join('\n');
  const moves=[]; for(const mv of moveHistory){ moves.push(mv.num+'. '+mv.w + (mv.b?(' '+mv.b):'')); }
  const body = moves.join(' ') + ' ' + (gameResult||'*');
  return headers+'\n\n'+body;
}

function resultFromMsg(msg){
  const s=(msg||'').toLowerCase();
  if(s.includes('brancas vencem')) return '1-0';
  if(s.includes('pretas vencem')) return '0-1';
  if(s.includes('empate')) return '1/2-1/2';
  return '*';
}
</script>
</body>
</html>